#!/bin/sh
#
# System Report - Comprehensive device information collector
#
# Generates a detailed report for platform development including:
# - CPU frequency scaling capabilities (governors, frequencies, write test)
# - CPU performance benchmarking at all available frequencies
# - Binary architecture support (32-bit vs 64-bit ELF)
# - System information (kernel, memory, storage)
# - Hardware paths and capabilities
#

# Get pak directory (parent of bin/)
SCRIPT_DIR="$(dirname "$0")"
PAK_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"

###############################################################################
# Cleanup and signal handling
###############################################################################

# Track background PIDs for cleanup on exit
CHILD_PIDS=""

cleanup_children() {
	for pid in $CHILD_PIDS; do
		kill "$pid" 2>/dev/null
		kill -9 "$pid" 2>/dev/null
	done
}

trap cleanup_children EXIT INT TERM HUP

###############################################################################
# Logging helpers - Markdown formatted output
###############################################################################

log_h1() {
	echo ""
	echo "# $*"
	echo ""
}

log_h2() {
	echo ""
	echo "## $*"
	echo ""
}

log_h3() {
	echo ""
	echo "### $*"
	echo ""
}

log_info() {
	echo "- **Info:** $*"
}

log_warn() {
	echo "- **Warning:** $*"
}

log_error() {
	echo "- **Error:** $*"
}

log_ok() {
	echo "- ✓ $*"
}

log_fail() {
	echo "- ✗ $*"
}

# Code block helpers
code_start() {
	echo '```'
}

code_end() {
	echo '```'
}

# Progress update helper - calls shui directly
progress() {
	pct="$1"
	msg="$2"
	shui progress "Generating report..." --value "$pct" --subtext "$msg" 2>/dev/null || true
}

# Run command with timeout
# Usage: with_timeout <seconds> <command> [args...]
# Returns: command exit code, or 124 on timeout (matching GNU timeout)
with_timeout() {
	secs="$1"
	shift
	if command -v timeout >/dev/null 2>&1; then
		timeout "$secs" "$@"
	else
		# Fallback: watchdog process pattern
		# Run command in background
		"$@" &
		cmd_pid=$!
		CHILD_PIDS="$CHILD_PIDS $cmd_pid"

		# Start watchdog that kills command after timeout
		(
			sleep "$secs"
			kill "$cmd_pid" 2>/dev/null
		) &
		watchdog_pid=$!
		CHILD_PIDS="$CHILD_PIDS $watchdog_pid"

		# Wait for command to finish (either naturally or killed by watchdog)
		wait "$cmd_pid" 2>/dev/null
		ret=$?

		# Kill watchdog if command finished before timeout
		kill "$watchdog_pid" 2>/dev/null
		wait "$watchdog_pid" 2>/dev/null

		# Return 124 if killed by signal (128+signal), else actual exit code
		if [ "$ret" -gt 128 ]; then
			return 124
		fi
		return "$ret"
	fi
}

# Safe wrappers for commands known to hang
# Stderr is suppressed here so callers get clean output
safe_iwconfig() {
	with_timeout 3 iwconfig "$@" 2>/dev/null
}

safe_iw() {
	with_timeout 3 iw "$@" 2>/dev/null
}

safe_wpa_cli() {
	with_timeout 3 wpa_cli "$@" 2>/dev/null
}

safe_ifconfig() {
	with_timeout 3 ifconfig "$@" 2>/dev/null
}

safe_hciconfig() {
	with_timeout 3 hciconfig "$@" 2>/dev/null
}

# Note: callers should pipe "quit" command to ensure bluetoothctl exits cleanly
safe_bluetoothctl() {
	with_timeout 3 bluetoothctl "$@" 2>/dev/null
}

###############################################################################
# CPU Frequency Scaling Detection (Most important for auto CPU scaling)
###############################################################################

fn_cpu_scaling() {
	log_h1 "CPU FREQUENCY SCALING ANALYSIS"

	log_h2 "Architecture Detection"

	echo "| Property | Value |"
	echo "|----------|-------|"
	echo "| uname -m | \`$(uname -m 2>/dev/null || echo 'N/A')\` |"
	echo "| uname -a | \`$(uname -a 2>/dev/null || echo 'N/A')\` |"

	log_h2 "CPU Info"
	if [ -f /proc/cpuinfo ]; then
		code_start
		cat /proc/cpuinfo 2>/dev/null || echo "[read error]"
		code_end
	else
		log_info "/proc/cpuinfo not found"
	fi

	log_h2 "CPU Topology"

	echo "| Property | Value |"
	echo "|----------|-------|"
	echo "| Online CPUs | \`$(cat /sys/devices/system/cpu/online 2>/dev/null || echo 'N/A')\` |"
	echo "| Possible CPUs | \`$(cat /sys/devices/system/cpu/possible 2>/dev/null || echo 'N/A')\` |"
	echo "| Present CPUs | \`$(cat /sys/devices/system/cpu/present 2>/dev/null || echo 'N/A')\` |"

	log_h2 "CPUFreq Subsystem Detection"

	# Check for cpufreq support
	if [ -d /sys/devices/system/cpu/cpufreq ]; then
		log_ok "cpufreq subsystem present"
		code_start
		ls -la /sys/devices/system/cpu/cpufreq/ 2>/dev/null || true
		code_end
	else
		log_warn "cpufreq subsystem not found at /sys/devices/system/cpu/cpufreq"
	fi

	# Check both common path patterns
	log_h3 "Path Pattern: policy0"
	POLICY0_PATH="/sys/devices/system/cpu/cpufreq/policy0"
	if [ -d "$POLICY0_PATH" ]; then
		log_ok "policy0 path exists"
		code_start
		ls -la "$POLICY0_PATH/" 2>/dev/null || true
		code_end
		echo ""
		echo "| File | Value |"
		echo "|------|-------|"
		for f in scaling_governor scaling_available_governors scaling_cur_freq \
			scaling_min_freq scaling_max_freq scaling_available_frequencies \
			scaling_setspeed cpuinfo_cur_freq cpuinfo_min_freq cpuinfo_max_freq \
			affected_cpus related_cpus; do
			if [ -f "$POLICY0_PATH/$f" ]; then
				echo "| $f | \`$(cat "$POLICY0_PATH/$f" 2>/dev/null || echo '[read error]')\` |"
			fi
		done
	else
		log_warn "policy0 path not found"
	fi

	log_h3 "Path Pattern: cpu0/cpufreq"
	CPU0_PATH="/sys/devices/system/cpu/cpu0/cpufreq"
	if [ -d "$CPU0_PATH" ]; then
		log_ok "cpu0/cpufreq path exists"
		code_start
		ls -la "$CPU0_PATH/" 2>/dev/null || true
		code_end
		echo ""
		echo "| File | Value |"
		echo "|------|-------|"
		for f in scaling_governor scaling_available_governors scaling_cur_freq \
			scaling_min_freq scaling_max_freq scaling_available_frequencies \
			scaling_setspeed cpuinfo_cur_freq cpuinfo_min_freq cpuinfo_max_freq \
			affected_cpus related_cpus; do
			if [ -f "$CPU0_PATH/$f" ]; then
				echo "| $f | \`$(cat "$CPU0_PATH/$f" 2>/dev/null || echo '[read error]')\` |"
			fi
		done
	else
		log_warn "cpu0/cpufreq path not found"
	fi

	log_h2 "CPU Frequency Write Test"
	log_info "Testing if we can actually change CPU frequency..."

	# Determine which path to use
	FREQ_PATH=""
	GOV_PATH=""
	if [ -f "$POLICY0_PATH/scaling_setspeed" ]; then
		FREQ_PATH="$POLICY0_PATH/scaling_setspeed"
		GOV_PATH="$POLICY0_PATH/scaling_governor"
	elif [ -f "$CPU0_PATH/scaling_setspeed" ]; then
		FREQ_PATH="$CPU0_PATH/scaling_setspeed"
		GOV_PATH="$CPU0_PATH/scaling_governor"
	fi

	if [ -n "$FREQ_PATH" ]; then
		log_info "Using frequency path: $FREQ_PATH"
		log_info "Using governor path: $GOV_PATH"

		# Save original state (CRITICAL: must restore both governor AND frequency)
		ORIG_GOV=""
		ORIG_FREQ=""
		if [ -f "$GOV_PATH" ]; then
			ORIG_GOV=$(cat "$GOV_PATH")
			log_info "Current governor: $ORIG_GOV"
		fi

		# Save original frequency BEFORE any writes
		for path in "$POLICY0_PATH/scaling_cur_freq" "$CPU0_PATH/scaling_cur_freq" \
			"$POLICY0_PATH/cpuinfo_cur_freq" "$CPU0_PATH/cpuinfo_cur_freq"; do
			if [ -f "$path" ]; then
				ORIG_FREQ=$(cat "$path" 2>/dev/null)
				if [ -n "$ORIG_FREQ" ]; then
					log_info "Current frequency: $ORIG_FREQ kHz (will restore after test)"
					break
				fi
			fi
		done

		# Read available frequencies
		AVAIL_FREQS=""
		for path in "$POLICY0_PATH/scaling_available_frequencies" "$CPU0_PATH/scaling_available_frequencies"; do
			if [ -f "$path" ]; then
				AVAIL_FREQS=$(cat "$path" 2>/dev/null)
				if [ -n "$AVAIL_FREQS" ]; then
					log_info "Available frequencies: $AVAIL_FREQS"
					break
				fi
			fi
		done

		# Read available governors
		AVAIL_GOVS=""
		for path in "$POLICY0_PATH/scaling_available_governors" "$CPU0_PATH/scaling_available_governors"; do
			if [ -f "$path" ]; then
				AVAIL_GOVS=$(cat "$path" 2>/dev/null)
				if [ -n "$AVAIL_GOVS" ]; then
					break
				fi
			fi
		done

		# Test 1: Governor switching (always safe, shows what freq each governor picks)
		if [ -n "$AVAIL_GOVS" ]; then
			log_h2 "Governor Switching Test"
			log_info "Testing each available governor to see what frequency it selects..."
			echo ""
			echo "| Governor | Resulting Frequency (kHz) |"
			echo "|----------|---------------------------|"
			for gov in $AVAIL_GOVS; do
				if echo "$gov" >"$GOV_PATH" 2>/dev/null; then
					sleep 1
					freq=$(cat "$POLICY0_PATH/scaling_cur_freq" 2>/dev/null || cat "$CPU0_PATH/scaling_cur_freq" 2>/dev/null || echo "N/A")
					echo "| $gov | \`$freq\` |"
				else
					echo "| $gov | *write failed* |"
				fi
			done
			log_info "Governor test complete"
		fi

		# Test 2: Manual frequency control (only if we can switch to userspace)
		log_h2 "Manual Frequency Control Test"
		if echo "userspace" >"$GOV_PATH" 2>/dev/null; then
			sleep 1
			if [ "$(cat "$GOV_PATH" 2>/dev/null)" = "userspace" ]; then
				log_ok "Switched to userspace governor for manual control"
				log_h3 "Frequency Write Test"

				# Get min and max
				MIN_FREQ=""
				MAX_FREQ=""
				for path in "$POLICY0_PATH" "$CPU0_PATH"; do
					if [ -z "$MIN_FREQ" ] && [ -f "$path/scaling_min_freq" ]; then
						MIN_FREQ=$(cat "$path/scaling_min_freq")
					fi
					if [ -z "$MAX_FREQ" ] && [ -f "$path/scaling_max_freq" ]; then
						MAX_FREQ=$(cat "$path/scaling_max_freq")
					fi
				done

				log_info "Min frequency: $MIN_FREQ kHz"
				log_info "Max frequency: $MAX_FREQ kHz"

				# Test writing min frequency
				if [ -n "$MIN_FREQ" ]; then
					log_info "Attempting to write $MIN_FREQ to $FREQ_PATH..."
					if echo "$MIN_FREQ" >"$FREQ_PATH" 2>/dev/null; then
						sleep 1
						NEW_FREQ=$(cat "$POLICY0_PATH/scaling_cur_freq" 2>/dev/null || cat "$CPU0_PATH/scaling_cur_freq" 2>/dev/null)
						if [ "$NEW_FREQ" = "$MIN_FREQ" ]; then
							log_ok "Frequency successfully changed to $MIN_FREQ kHz"
						else
							log_warn "Write succeeded but frequency is $NEW_FREQ (expected $MIN_FREQ)"
						fi
					else
						log_fail "Could not write frequency (permission denied?)"
					fi
				fi

				# Test writing max frequency
				if [ -n "$MAX_FREQ" ]; then
					log_info "Attempting to write $MAX_FREQ to $FREQ_PATH..."
					if echo "$MAX_FREQ" >"$FREQ_PATH" 2>/dev/null; then
						sleep 1
						NEW_FREQ=$(cat "$POLICY0_PATH/scaling_cur_freq" 2>/dev/null || cat "$CPU0_PATH/scaling_cur_freq" 2>/dev/null)
						if [ "$NEW_FREQ" = "$MAX_FREQ" ]; then
							log_ok "Frequency successfully changed to $MAX_FREQ kHz"
						else
							log_warn "Write succeeded but frequency is $NEW_FREQ (expected $MAX_FREQ)"
						fi
					else
						log_fail "Could not write frequency (permission denied?)"
					fi
				fi

				# If we have available frequencies, test a sweep
				if [ -n "$AVAIL_FREQS" ]; then
					log_h3 "Frequency Sweep Test"
					echo ""
					echo "| Frequency (kHz) | Result |"
					echo "|-----------------|--------|"
					for freq in $AVAIL_FREQS; do
						if echo "$freq" >"$FREQ_PATH" 2>/dev/null; then
							sleep 1
							actual=$(cat "$POLICY0_PATH/scaling_cur_freq" 2>/dev/null || cat "$CPU0_PATH/scaling_cur_freq" 2>/dev/null)
							if [ "$actual" = "$freq" ]; then
								echo "| $freq | ✓ OK |"
							else
								echo "| $freq | ⚠ wrote OK but actual=$actual |"
							fi
						else
							echo "| $freq | ✗ WRITE FAILED |"
						fi
					done
				fi
			else
				log_warn "Could not switch to userspace - manual frequency control not available"
			fi
		fi

		# Restore original state
		if [ -n "$ORIG_GOV" ]; then
			echo "$ORIG_GOV" >"$GOV_PATH" 2>/dev/null
			log_info "Restored governor: $ORIG_GOV"
		fi
		if [ -n "$ORIG_FREQ" ]; then
			echo "$ORIG_FREQ" >"$FREQ_PATH" 2>/dev/null
			log_info "Restored frequency: $ORIG_FREQ kHz"
		fi
	else
		log_warn "No scaling_setspeed file found"
	fi

	log_h2 "CPU Scaling Summary"
	echo ""
	echo "| Path | Value |"
	echo "|------|-------|"
	if [ -n "$FREQ_PATH" ]; then
		echo "| scaling_setspeed | \`$FREQ_PATH\` |"
		echo "| scaling_governor | \`$GOV_PATH\` |"
	else
		echo "| scaling_setspeed | *not found* |"
	fi
}

###############################################################################
# CPU Performance Benchmark
###############################################################################

fn_cpu_benchmark() {
	log_h1 "CPU PERFORMANCE BENCHMARK"

	# Check if we can run benchmarks (need userspace governor and available freqs)
	if [ -z "$FREQ_PATH" ] || [ -z "$GOV_PATH" ]; then
		log_warn "Cannot run benchmark - CPU frequency control not available"
		return
	fi

	# Check for userspace governor availability
	AVAIL_GOVS=""
	for path in "$POLICY0_PATH/scaling_available_governors" "$CPU0_PATH/scaling_available_governors"; do
		if [ -f "$path" ]; then
			AVAIL_GOVS=$(cat "$path" 2>/dev/null)
			break
		fi
	done

	if ! echo "$AVAIL_GOVS" | grep -qw "userspace" 2>/dev/null; then
		log_warn "Cannot run benchmark - userspace governor not available"
		return
	fi

	# Get available frequencies
	AVAIL_FREQS=""
	for path in "$POLICY0_PATH/scaling_available_frequencies" "$CPU0_PATH/scaling_available_frequencies"; do
		if [ -f "$path" ]; then
			AVAIL_FREQS=$(cat "$path" 2>/dev/null)
			break
		fi
	done

	# Fallback: probe for frequencies by writing values and seeing what sticks
	if [ -z "$AVAIL_FREQS" ]; then
		log_info "scaling_available_frequencies not found, probing for valid frequencies..."

		# Get min/max from sysfs
		MIN_FREQ=""
		MAX_FREQ=""
		for path in "$POLICY0_PATH" "$CPU0_PATH"; do
			[ -z "$MIN_FREQ" ] && [ -f "$path/scaling_min_freq" ] && MIN_FREQ=$(cat "$path/scaling_min_freq" 2>/dev/null)
			[ -z "$MAX_FREQ" ] && [ -f "$path/scaling_max_freq" ] && MAX_FREQ=$(cat "$path/scaling_max_freq" 2>/dev/null)
		done

		if [ -n "$MIN_FREQ" ] && [ -n "$MAX_FREQ" ] && [ -n "$FREQ_PATH" ]; then
			# Switch to userspace governor for probing
			echo "userspace" >"$GOV_PATH" 2>/dev/null
			sleep 0.2

			# Probe from min to max in 100MHz steps
			DISCOVERED_FREQS=""
			LAST_ACTUAL=""
			freq=$MIN_FREQ
			while [ "$freq" -le "$MAX_FREQ" ]; do
				echo "$freq" >"$FREQ_PATH" 2>/dev/null
				# Small delay for frequency to settle
				usleep 50000 2>/dev/null || sleep 0.05

				# Read what frequency was actually set
				ACTUAL=$(cat "$POLICY0_PATH/scaling_cur_freq" 2>/dev/null || cat "$CPU0_PATH/scaling_cur_freq" 2>/dev/null)

				# Only add if different from last (avoid duplicates)
				if [ -n "$ACTUAL" ] && [ "$ACTUAL" != "$LAST_ACTUAL" ]; then
					DISCOVERED_FREQS="$DISCOVERED_FREQS $ACTUAL"
					LAST_ACTUAL="$ACTUAL"
				fi

				freq=$((freq + 100000))
			done

			# Sort and dedupe the discovered frequencies
			if [ -n "$DISCOVERED_FREQS" ]; then
				AVAIL_FREQS=$(echo "$DISCOVERED_FREQS" | tr ' ' '\n' | sort -n | uniq | tr '\n' ' ')
				log_info "Discovered frequencies: $AVAIL_FREQS"
			fi
		fi
	fi

	if [ -z "$AVAIL_FREQS" ]; then
		log_warn "Cannot run benchmark - no available frequencies found"
		return
	fi

	# Check for benchmark binary
	BENCHMARK_BIN="$PAK_DIR/bin/benchmark.elf"
	if [ ! -x "$BENCHMARK_BIN" ]; then
		log_warn "Cannot run benchmark - benchmark.elf not found"
		return
	fi

	log_info "Running 1-second benchmark at each frequency..."
	echo ""

	# Save current state
	ORIG_GOV=$(cat "$GOV_PATH" 2>/dev/null)
	ORIG_FREQ=""
	for path in "$POLICY0_PATH/scaling_cur_freq" "$CPU0_PATH/scaling_cur_freq" \
		"$POLICY0_PATH/cpuinfo_cur_freq" "$CPU0_PATH/cpuinfo_cur_freq"; do
		if [ -f "$path" ]; then
			ORIG_FREQ=$(cat "$path" 2>/dev/null)
			[ -n "$ORIG_FREQ" ] && break
		fi
	done

	# Switch to userspace governor
	echo "userspace" >"$GOV_PATH" 2>/dev/null
	sleep 0.5

	# Test benchmark binary before running
	log_info "Benchmark binary: $BENCHMARK_BIN"
	if ! BENCH_TEST=$("$BENCHMARK_BIN" 100 0 2>&1); then
		log_warn "Benchmark binary failed to run: $BENCH_TEST"
		return
	fi
	log_info "Benchmark test run: $BENCH_TEST"

	# Run benchmark at each frequency
	echo ""
	echo "| Frequency (kHz) | Iterations | Performance Index |"
	echo "|-----------------|------------|-------------------|"

	FIRST_ITERATIONS=""
	for freq in $AVAIL_FREQS; do
		# Set frequency
		echo "$freq" >"$FREQ_PATH" 2>/dev/null
		sleep 0.2

		# Run 1 second benchmark (no warmup)
		RESULT=$("$BENCHMARK_BIN" 1000 0 2>&1)
		ITERATIONS=$(echo "$RESULT" | cut -d' ' -f1)

		# Handle empty result
		if [ -z "$ITERATIONS" ] || [ "$ITERATIONS" = "0" ]; then
			echo "| $freq | *failed* | - |"
			continue
		fi

		# Calculate performance index (relative to first frequency)
		if [ -z "$FIRST_ITERATIONS" ]; then
			FIRST_ITERATIONS=$ITERATIONS
			PERF_INDEX="1.00x"
		else
			# Use awk for floating point division
			PERF_INDEX=$(echo "$ITERATIONS $FIRST_ITERATIONS" | awk '{printf "%.2fx", $1/$2}')
		fi

		# Format iterations with commas for readability
		ITER_FMT=$(echo "$ITERATIONS" | awk '{printf "%\047d", $1}')

		echo "| $freq | $ITER_FMT | $PERF_INDEX |"
	done

	echo ""
	log_info "Benchmark complete"

	# Restore original state
	if [ -n "$ORIG_GOV" ]; then
		echo "$ORIG_GOV" >"$GOV_PATH" 2>/dev/null
	fi
	if [ -n "$ORIG_FREQ" ]; then
		echo "$ORIG_FREQ" >"$FREQ_PATH" 2>/dev/null
	fi
}

###############################################################################
# GPU / Device Frequency Scaling
###############################################################################

fn_gpu() {
	log_h1 "GPU / DEVFREQ"

	log_h2 "Device Frequency Scaling"
	if [ -d /sys/class/devfreq ]; then
		for dev in /sys/class/devfreq/*; do
			if [ -d "$dev" ]; then
				log_h3 "$(basename "$dev")"
				echo "| Property | Value |"
				echo "|----------|-------|"
				for f in governor available_governors cur_freq min_freq max_freq \
					available_frequencies target_freq; do
					if [ -f "$dev/$f" ]; then
						echo "| $f | \`$(cat "$dev/$f" 2>/dev/null || echo '[error]')\` |"
					fi
				done
			fi
		done
	else
		log_info "/sys/class/devfreq not found"
	fi

	log_h2 "Mali GPU"
	found_mali=0
	for mali in /sys/class/misc/mali* /sys/devices/platform/*.gpu /sys/devices/platform/*/gpu; do
		if [ -d "$mali" ]; then
			found_mali=1
			log_h3 "$mali"
			code_start
			ls -la "$mali/" 2>/dev/null || true
			code_end
		fi
	done 2>/dev/null
	if [ "$found_mali" = "0" ]; then
		log_info "No Mali GPU paths found"
	fi
}

###############################################################################
# Audio Subsystem
###############################################################################

fn_audio() {
	log_h1 "AUDIO SUBSYSTEM"

	log_h2 "ALSA Sound Cards"
	if [ -f /proc/asound/cards ]; then
		code_start
		cat /proc/asound/cards 2>/dev/null || echo "[read error]"
		code_end
	else
		log_info "/proc/asound/cards not found"
	fi

	log_h2 "ALSA Devices"
	if [ -d /proc/asound ]; then
		code_start
		ls -la /proc/asound/ 2>/dev/null || true
		code_end
	else
		log_info "/proc/asound not found"
	fi

	log_h2 "Sound Class"
	if [ -d /sys/class/sound ]; then
		code_start
		ls -la /sys/class/sound/ 2>/dev/null || true
		code_end
		echo ""
		found_cards=0
		for card in /sys/class/sound/card*; do
			if [ -d "$card" ]; then
				if [ "$found_cards" = "0" ]; then
					echo "| Card | ID |"
					echo "|------|-----|"
					found_cards=1
				fi
				cardname=$(basename "$card")
				cardid=$(cat "$card/id" 2>/dev/null || echo "unknown")
				echo "| $cardname | \`$cardid\` |"
			fi
		done 2>/dev/null
		if [ "$found_cards" = "0" ]; then
			log_info "No sound cards found"
		fi
	else
		log_info "/sys/class/sound not found"
	fi

	log_h2 "PCM Devices"
	if [ -f /proc/asound/pcm ]; then
		code_start
		cat /proc/asound/pcm 2>/dev/null || echo "[read error]"
		code_end
	else
		log_info "/proc/asound/pcm not found"
	fi

	log_h2 "Audio Device Nodes"
	code_start
	ls -la /dev/snd/* 2>/dev/null || echo "No /dev/snd devices"
	ls -la /dev/dsp /dev/audio /dev/mixer 2>/dev/null || true
	code_end

	log_h2 "ALSA Configuration Files"
	found_cfg=0
	for cfg in /etc/asound.conf ~/.asoundrc /usr/share/alsa/alsa.conf; do
		if [ -f "$cfg" ]; then
			found_cfg=1
			log_ok "Found: $cfg"
			code_start
			head -30 "$cfg" 2>/dev/null || true
			code_end
		fi
	done
	if [ "$found_cfg" = "0" ]; then
		log_info "No ALSA config files found"
	fi
}

###############################################################################
# Display/Framebuffer
###############################################################################

fn_display() {
	log_h1 "DISPLAY / FRAMEBUFFER"

	log_h2 "Framebuffer Devices"
	code_start
	ls -la /dev/fb* 2>/dev/null || echo "No framebuffer devices found"
	code_end

	log_h2 "Framebuffer 0 Details"
	FB0="/sys/class/graphics/fb0"
	if [ -d "$FB0" ]; then
		code_start
		ls -la "$FB0/" 2>/dev/null || true
		code_end
		echo ""
		echo "| Property | Value |"
		echo "|----------|-------|"
		for f in bits_per_pixel virtual_size stride name modes pan; do
			if [ -f "$FB0/$f" ]; then
				echo "| $f | \`$(cat "$FB0/$f" 2>/dev/null || echo '[read error]')\` |"
			fi
		done
	else
		log_info "/sys/class/graphics/fb0 not found"
	fi

	log_h2 "fbset Output"
	if command -v fbset >/dev/null 2>&1; then
		code_start
		fbset 2>/dev/null || echo "fbset failed"
		code_end
	else
		log_info "fbset not available"
	fi

	log_h2 "DRM Subsystem"
	if [ -d /sys/class/drm ]; then
		code_start
		ls -la /sys/class/drm/ 2>/dev/null || true
		code_end
		for card in /sys/class/drm/card*; do
			if [ -d "$card" ]; then
				log_h3 "$(basename "$card")"
				echo "| Property | Value |"
				echo "|----------|-------|"
				for f in status enabled modes; do
					if [ -f "$card/$f" ]; then
						echo "| $f | \`$(cat "$card/$f" 2>/dev/null || echo '[read error]')\` |"
					fi
				done
			fi
		done 2>/dev/null
	else
		log_info "/sys/class/drm not found"
	fi

	log_h2 "HDMI Detection"

	# Comprehensive HDMI detection across all known path formats
	found_hdmi=0
	hdmi_connected=0
	hdmi_state_path=""

	echo "| Path | State | Format |"
	echo "|------|-------|--------|"

	# Check all known HDMI state paths
	for hdmi_path in \
		/sys/class/switch/hdmi/cable.0/state \
		/sys/class/extcon/hdmi/cable.0/state \
		/sys/class/switch/hdmi/state \
		/sys/class/drm/card0-HDMI-A-1/status \
		/sys/class/drm/card1-HDMI-A-1/status \
		/sys/devices/virtual/switch/hdmi/state \
		/sys/devices/virtual/extcon/hdmi/state; do
		if [ -f "$hdmi_path" ]; then
			found_hdmi=1
			state_value=$(cat "$hdmi_path" 2>/dev/null || echo '[read error]')

			# Determine format (numeric vs string)
			state_format="unknown"
			case "$state_value" in
				0 | 1)
					state_format="numeric (0=off, 1=on)"
					[ "$state_value" = "1" ] && hdmi_connected=1
					;;
				connected*)
					state_format="string (connected/disconnected)"
					hdmi_connected=1
					;;
				disconnected*)
					state_format="string (connected/disconnected)"
					;;
			esac

			echo "| \`$hdmi_path\` | \`$state_value\` | $state_format |"

			# Save first found path for summary
			if [ -z "$hdmi_state_path" ]; then
				hdmi_state_path="$hdmi_path"
			fi
		fi
	done 2>/dev/null

	if [ "$found_hdmi" = "0" ]; then
		echo "| *No HDMI state files found* | - | - |"
	fi

	# HDMI Output Capabilities
	log_h3 "HDMI Output Capabilities"

	echo ""
	echo "| Property | Value |"
	echo "|----------|-------|"

	# Check for HDMI audio devices
	hdmi_audio_found=0
	for audio_dev in /proc/asound/card*/id; do
		if [ -f "$audio_dev" ]; then
			card_id=$(cat "$audio_dev" 2>/dev/null)
			if echo "$card_id" | grep -qi "hdmi"; then
				hdmi_audio_found=1
				card_num=$(echo "$audio_dev" | sed 's/.*card\([0-9]*\).*/\1/')
				echo "| HDMI audio device | \`hw:$card_num,0\` ($card_id) |"
			fi
		fi
	done 2>/dev/null

	if [ "$hdmi_audio_found" = "0" ]; then
		echo "| HDMI audio device | not detected |"
	fi

	# Check for DRM display modes
	for drm_modes in /sys/class/drm/card*-HDMI-*/modes; do
		if [ -f "$drm_modes" ]; then
			modes=$(cat "$drm_modes" 2>/dev/null | tr '\n' ', ' | sed 's/,$//')
			if [ -n "$modes" ]; then
				card_name=$(dirname "$drm_modes" | xargs basename)
				echo "| $card_name modes | \`$modes\` |"
			fi
		fi
	done 2>/dev/null

	# Check for HDMI EDID (Extended Display Identification Data)
	for edid in /sys/class/drm/card*-HDMI-*/edid; do
		if [ -f "$edid" ]; then
			edid_size=$(wc -c <"$edid" 2>/dev/null || echo "0")
			if [ "$edid_size" -gt 0 ]; then
				card_name=$(dirname "$edid" | xargs basename)
				echo "| $card_name EDID | ${edid_size} bytes |"

				# Try to parse EDID if edid-decode is available
				if command -v edid-decode >/dev/null 2>&1; then
					monitor_name=$(edid-decode "$edid" 2>/dev/null | grep "Display Product Name:" | cut -d: -f2- | xargs)
					[ -n "$monitor_name" ] && echo "| Monitor name | $monitor_name |"
				fi
			fi
		fi
	done 2>/dev/null

	# Check for dispdbg interface (rg35xxplus specific)
	if [ -d /sys/kernel/debug/dispdbg ]; then
		echo "| dispdbg interface | ✓ Present (rg35xxplus display control) |"

		# Show dispdbg contents if readable
		if [ -f /sys/kernel/debug/dispdbg/name ]; then
			disp_name=$(cat /sys/kernel/debug/dispdbg/name 2>/dev/null)
			[ -n "$disp_name" ] && echo "| dispdbg name | \`$disp_name\` |"
		fi
	fi

	# Check for extcon (external connector) subsystem
	log_h3 "HDMI Extcon Subsystem"

	if [ -d /sys/class/extcon ]; then
		found_extcon=0
		for extcon_dev in /sys/class/extcon/*; do
			if [ -d "$extcon_dev" ]; then
				dev_name=$(basename "$extcon_dev")
				if [ -f "$extcon_dev/name" ]; then
					extcon_name=$(cat "$extcon_dev/name" 2>/dev/null)
					if echo "$extcon_name" | grep -qi "hdmi"; then
						found_extcon=1
						echo ""
						echo "| Property | Value |"
						echo "|----------|-------|"
						echo "| Device | \`$dev_name\` |"
						echo "| Name | $extcon_name |"

						# Check cable state
						if [ -f "$extcon_dev/cable.0/state" ]; then
							cable_state=$(cat "$extcon_dev/cable.0/state" 2>/dev/null)
							echo "| Cable state | $cable_state |"
						fi

						# List supported cables
						if [ -f "$extcon_dev/state" ]; then
							state=$(cat "$extcon_dev/state" 2>/dev/null)
							echo "| State | \`$state\` |"
						fi
					fi
				fi
			fi
		done 2>/dev/null

		if [ "$found_extcon" = "0" ]; then
			log_info "No HDMI extcon devices found"
		fi
	else
		log_info "Extcon subsystem not available"
	fi

	# Check for fbset command availability
	log_h3 "HDMI Display Control Tools"

	echo ""
	echo "| Tool | Status | Purpose |"
	echo "|------|--------|---------|"

	if command -v fbset >/dev/null 2>&1; then
		echo "| fbset | ✓ Available | Framebuffer mode switching |"
	else
		echo "| fbset | ✗ Not found | Cannot switch HDMI modes |"
	fi

	if [ -d /sys/kernel/debug/dispdbg ]; then
		echo "| dispdbg | ✓ Available | rg35xxplus display switching |"
	else
		echo "| dispdbg | Not found | Platform may use different method |"
	fi

	# Check for HDMI monitor daemon
	if ps aux 2>/dev/null | grep -q "[h]dmimon"; then
		echo "| hdmimon daemon | ✓ Running | Monitors HDMI hotplug events |"
	else
		echo "| hdmimon daemon | Not running | HDMI hotplug may not work |"
	fi

	# Summary
	log_h3 "HDMI Status Summary"

	echo ""
	echo "| Feature | Status |"
	echo "|---------|--------|"

	if [ "$found_hdmi" = "1" ]; then
		echo "| HDMI detection path | ✓ Found (\`$hdmi_state_path\`) |"

		if [ "$hdmi_connected" = "1" ]; then
			echo "| Current state | ✓ **Connected** |"
		else
			echo "| Current state | Disconnected |"
		fi
	else
		echo "| HDMI support | ✗ No detection paths found |"
	fi

	if [ "$hdmi_audio_found" = "1" ]; then
		echo "| HDMI audio | ✓ Available |"
	else
		echo "| HDMI audio | Not detected |"
	fi

	log_h2 "Screen Rotation Detection"

	# Method 1: Direct rotate sysfs node
	if [ -f "$FB0/rotate" ]; then
		ROTATE=$(cat "$FB0/rotate" 2>/dev/null || echo "N/A")
		case "$ROTATE" in
			0) log_ok "Rotation: **0° (normal)** - \`$FB0/rotate\`" ;;
			1) log_ok "Rotation: **90° clockwise** - \`$FB0/rotate\`" ;;
			2) log_ok "Rotation: **180°** - \`$FB0/rotate\`" ;;
			3) log_ok "Rotation: **270° clockwise (90° CCW)** - \`$FB0/rotate\`" ;;
			*) log_info "Rotation value: $ROTATE - \`$FB0/rotate\`" ;;
		esac
	else
		log_info "No rotate sysfs node at \`$FB0/rotate\`"
	fi

	# Method 2: Compare virtual_size vs fbset geometry (dimension swap indicates rotation)
	if [ -f "$FB0/virtual_size" ] && command -v fbset >/dev/null 2>&1; then
		VIRTUAL_SIZE=$(cat "$FB0/virtual_size" 2>/dev/null)
		FBSET_GEOM=$(fbset 2>/dev/null | grep "geometry" | head -1)
		if [ -n "$VIRTUAL_SIZE" ] && [ -n "$FBSET_GEOM" ]; then
			VIRT_W=$(echo "$VIRTUAL_SIZE" | cut -d, -f1)
			VIRT_H=$(echo "$VIRTUAL_SIZE" | cut -d, -f2)
			PHYS_W=$(echo "$FBSET_GEOM" | awk '{print $2}')
			PHYS_H=$(echo "$FBSET_GEOM" | awk '{print $3}')

			echo ""
			echo "| Dimension | Virtual | Physical |"
			echo "|-----------|---------|----------|"
			echo "| Width | $VIRT_W | $PHYS_W |"
			echo "| Height | $VIRT_H | $PHYS_H |"

			if [ "$VIRT_W" != "$PHYS_W" ] || [ "$VIRT_H" != "$PHYS_H" ]; then
				if [ "$VIRT_W" = "$PHYS_H" ] && [ "$VIRT_H" = "$PHYS_W" ]; then
					log_warn "Dimensions swapped - likely **90° or 270° rotation**"
				else
					log_warn "Virtual/physical size mismatch - possible rotation or scaling"
				fi
			else
				log_info "Virtual and physical sizes match (no dimension swap)"
			fi
		fi
	fi

	# Method 3: Kernel command line rotation parameter
	if [ -f /proc/cmdline ]; then
		if grep -q "fbcon=rotate" /proc/cmdline 2>/dev/null; then
			ROTATE_PARAM=$(grep -o 'fbcon=rotate:[0-9]' /proc/cmdline 2>/dev/null || echo "")
			log_ok "Kernel cmdline rotation: \`$ROTATE_PARAM\`"
		fi
	fi

	# Method 4: DRM rotation (if available)
	for plane in /sys/class/drm/card*/card*/rotation; do
		if [ -f "$plane" ]; then
			DRM_ROT=$(cat "$plane" 2>/dev/null)
			log_info "DRM rotation property: \`$DRM_ROT\` at \`$plane\`"
		fi
	done 2>/dev/null
}

###############################################################################
# Device Tree
###############################################################################

fn_device_tree() {
	log_h1 "DEVICE TREE"

	log_h2 "Device Identification"
	echo "| Property | Value |"
	echo "|----------|-------|"
	if [ -f /proc/device-tree/model ]; then
		echo "| Model | \`$(cat /proc/device-tree/model 2>/dev/null | tr -d '\0' || echo '[read error]')\` |"
	else
		echo "| Model | *not found* |"
	fi
	if [ -f /proc/device-tree/compatible ]; then
		echo "| Compatible | \`$(cat /proc/device-tree/compatible 2>/dev/null | tr '\0' ' ' || echo '[read error]')\` |"
	else
		echo "| Compatible | *not found* |"
	fi

	log_h2 "SoC/Chip Info"
	echo "| Path | Value |"
	echo "|------|-------|"
	for f in /proc/device-tree/soc/compatible \
		/sys/firmware/devicetree/base/compatible \
		/sys/devices/soc0/soc_id \
		/sys/devices/soc0/machine \
		/sys/devices/soc0/family \
		/sys/devices/soc0/revision; do
		if [ -f "$f" ]; then
			val=$(cat "$f" 2>/dev/null | tr '\0' ' ' || echo '[read error]')
			echo "| \`$f\` | \`$val\` |"
		fi
	done

	log_h2 "Device Tree Base Structure"
	if [ -d /proc/device-tree ]; then
		code_start
		ls /proc/device-tree/ 2>/dev/null | head -30 || true
		code_end
	elif [ -d /sys/firmware/devicetree/base ]; then
		code_start
		ls /sys/firmware/devicetree/base/ 2>/dev/null | head -30 || true
		code_end
	else
		log_info "No device tree found"
	fi
}

###############################################################################
# Kernel Messages
###############################################################################

fn_dmesg() {
	log_h1 "KERNEL MESSAGES (last 100 lines)"

	if command -v dmesg >/dev/null 2>&1; then
		code_start
		dmesg 2>/dev/null | tail -100 || echo "dmesg failed"
		code_end
	else
		log_info "dmesg not available"
	fi
}

###############################################################################
# Kernel Modules
###############################################################################

fn_modules() {
	log_h1 "KERNEL MODULES"

	log_h2 "Loaded Modules"
	if command -v lsmod >/dev/null 2>&1; then
		code_start
		lsmod 2>/dev/null || echo "lsmod failed"
		code_end
	elif [ -f /proc/modules ]; then
		code_start
		cat /proc/modules 2>/dev/null || echo "Could not read /proc/modules"
		code_end
	else
		log_info "No module information available"
	fi

	log_h2 "Module Parameters"
	if [ -d /sys/module ]; then
		echo "| Module | Parameters |"
		echo "|--------|------------|"
		for mod in /sys/module/*/parameters; do
			if [ -d "$mod" ]; then
				modname=$(dirname "$mod" | xargs basename)
				params=$(ls "$mod" 2>/dev/null | head -5 | tr '\n' ' ')
				if [ -n "$params" ]; then
					echo "| $modname | \`$params\` |"
				fi
			fi
		done 2>/dev/null | head -30
	else
		log_info "/sys/module not found"
	fi
}

###############################################################################
# PWM Subsystem
###############################################################################

fn_pwm() {
	log_h1 "PWM SUBSYSTEM"

	if [ -d /sys/class/pwm ]; then
		code_start
		ls -la /sys/class/pwm/ 2>/dev/null || true
		code_end
		for chip in /sys/class/pwm/pwmchip*; do
			if [ -d "$chip" ]; then
				log_h2 "$(basename "$chip")"
				echo "| Property | Value |"
				echo "|----------|-------|"
				if [ -f "$chip/npwm" ]; then
					echo "| npwm | \`$(cat "$chip/npwm" 2>/dev/null || echo '[read error]')\` |"
				fi
				# List any exported PWM channels
				for pwm in "$chip"/pwm*; do
					if [ -d "$pwm" ]; then
						log_h3 "$(basename "$pwm")"
						echo "| Property | Value |"
						echo "|----------|-------|"
						for pf in period duty_cycle enable polarity; do
							if [ -f "$pwm/$pf" ]; then
								pval=$(cat "$pwm/$pf" 2>/dev/null || echo '[read error]')
								echo "| $pf | \`$pval\` |"
							fi
						done
					fi
				done 2>/dev/null
			fi
		done 2>/dev/null
	else
		log_info "/sys/class/pwm not found"
	fi
}

###############################################################################
# System Buses (I2C, SPI, USB)
###############################################################################

fn_buses() {
	log_h1 "SYSTEM BUSES"

	log_h2 "I2C Devices"
	if [ -d /sys/bus/i2c/devices ]; then
		code_start
		ls -la /sys/bus/i2c/devices/ 2>/dev/null || true
		code_end
	else
		log_info "/sys/bus/i2c/devices not found"
	fi

	log_h2 "SPI Devices"
	if [ -d /sys/bus/spi/devices ]; then
		code_start
		ls -la /sys/bus/spi/devices/ 2>/dev/null || true
		code_end
	else
		log_info "/sys/bus/spi/devices not found"
	fi

	log_h2 "USB Devices"
	if command -v lsusb >/dev/null 2>&1; then
		code_start
		lsusb 2>/dev/null || echo "lsusb failed"
		code_end
	else
		log_info "lsusb not available"
	fi

	# USB device tree via sysfs
	if [ -d /sys/bus/usb/devices ]; then
		log_h3 "USB Device Tree"
		code_start
		ls /sys/bus/usb/devices/ 2>/dev/null || true
		code_end
	fi

	log_h2 "USB Mode Detection"

	# Detect USB controller capabilities
	has_host=0
	has_gadget=0
	has_otg=0

	# Check for USB host controllers
	if [ -d /sys/bus/usb/devices ] && [ -n "$(ls -A /sys/bus/usb/devices 2>/dev/null)" ]; then
		has_host=1
	fi

	# Check for USB gadget/device mode support (UDC)
	if [ -d /sys/class/udc ] && [ -n "$(ls -A /sys/class/udc 2>/dev/null)" ]; then
		has_gadget=1
	fi

	# Check for OTG capabilities (can do both)
	for otg in /sys/bus/platform/devices/*/otg_mode /sys/class/usb_role/*/role; do
		if [ -f "$otg" ]; then
			has_otg=1
			break
		fi
	done 2>/dev/null

	echo ""
	echo "| Capability | Status | Details |"
	echo "|------------|--------|---------|"

	if [ "$has_host" = "1" ]; then
		echo "| USB Host | ✓ Supported | Can use USB devices (storage, controllers, etc.) |"
	else
		echo "| USB Host | ✗ Not detected | No USB host controllers found |"
	fi

	if [ "$has_gadget" = "1" ]; then
		echo "| USB Gadget | ✓ Supported | Can act as USB device (mass storage, serial, etc.) |"
	else
		echo "| USB Gadget | ✗ Not detected | No USB Device Controller (UDC) found |"
	fi

	if [ "$has_otg" = "1" ]; then
		echo "| USB OTG | ✓ Supported | Can switch between host and device modes |"
	else
		echo "| USB OTG | ✗ Not detected | No OTG role switching detected |"
	fi

	# Show current USB role if OTG
	log_h3 "USB OTG Role (if applicable)"
	found_role=0
	for role_file in /sys/class/usb_role/*/role /sys/bus/platform/devices/*/otg_mode; do
		if [ -f "$role_file" ]; then
			found_role=1
			role_path=$(dirname "$role_file")
			role_name=$(basename "$role_path")
			current_role=$(cat "$role_file" 2>/dev/null || echo "unknown")
			echo "- \`$role_name\`: **$current_role**"
		fi
	done 2>/dev/null

	if [ "$found_role" = "0" ]; then
		log_info "No OTG role files found"
	fi

	# USB Gadget details
	log_h3 "USB Gadget / Device Mode"
	if [ -d /sys/class/udc ]; then
		code_start
		ls -la /sys/class/udc/ 2>/dev/null || true
		code_end
		for udc in /sys/class/udc/*; do
			if [ -d "$udc" ]; then
				log_h3 "UDC: $(basename "$udc")"
				echo "| Property | Value |"
				echo "|----------|-------|"
				for f in state current_speed maximum_speed; do
					if [ -f "$udc/$f" ]; then
						echo "| $f | \`$(cat "$udc/$f" 2>/dev/null || echo 'N/A')\` |"
					fi
				done
			fi
		done 2>/dev/null
	else
		log_info "/sys/class/udc not found (no USB gadget support)"
	fi

	# USB-C Video Output Detection (DisplayPort Alt Mode, MHL, etc.)
	log_h2 "USB-C Video Output Detection"

	echo ""
	echo "| Feature | Status | Details |"
	echo "|---------|--------|---------|"

	# Check for DisplayPort Alt Mode support via typec subsystem
	found_typec=0
	if [ -d /sys/class/typec ]; then
		for port in /sys/class/typec/port*; do
			if [ -d "$port" ]; then
				found_typec=1
				port_name=$(basename "$port")

				# Check supported alternate modes
				if [ -d "$port/port0-partner" ]; then
					for altmode in "$port"/port0-partner*/mode*; do
						if [ -d "$altmode" ]; then
							mode_name=$(cat "$altmode/description" 2>/dev/null || echo "unknown")
							active=$(cat "$altmode/active" 2>/dev/null)

							if echo "$mode_name" | grep -qi "displayport\|dp"; then
								if [ "$active" = "yes" ]; then
									echo "| USB-C DisplayPort | ✓ Active | $port_name - DP Alt Mode active |"
								else
									echo "| USB-C DisplayPort | ○ Supported | $port_name - DP Alt Mode available |"
								fi
							fi
						fi
					done 2>/dev/null
				fi

				# Check port capabilities
				if [ -f "$port/data_role" ]; then
					data_role=$(cat "$port/data_role" 2>/dev/null)
					echo "| $port_name data role | \`$data_role\` | - |"
				fi

				if [ -f "$port/power_role" ]; then
					power_role=$(cat "$port/power_role" 2>/dev/null)
					echo "| $port_name power role | \`$power_role\` | - |"
				fi
			fi
		done 2>/dev/null
	fi

	# Check for MHL (Mobile High-Definition Link) support
	if [ -d /sys/class/mhl ]; then
		echo "| MHL (Mobile HD Link) | ✓ Supported | USB-C to HDMI via MHL adapter |"
	fi

	# Check for USB Type-C port manager
	if [ -d /sys/class/typec_mux ]; then
		echo "| USB-C Mux | ✓ Present | Can switch between modes |"
	fi

	# Check for DRM DisplayPort
	for dp in /sys/class/drm/card*-DP-*; do
		if [ -d "$dp" ]; then
			dp_name=$(basename "$dp")
			if [ -f "$dp/status" ]; then
				dp_status=$(cat "$dp/status" 2>/dev/null)
				if [ "$dp_status" = "connected" ]; then
					echo "| DisplayPort | ✓ Connected | $dp_name active |"
				else
					echo "| DisplayPort | ○ Supported | $dp_name available |"
				fi
			fi
		fi
	done 2>/dev/null

	# Check USB-C port controller chips (common ICs)
	log_h3 "USB-C Controller Detection"

	found_usbc_controller=0
	echo ""
	echo "| Controller | Path | Type |"
	echo "|------------|------|------|"

	# Check I2C for USB-C port controllers
	for i2c_dev in /sys/bus/i2c/devices/*/name; do
		if [ -f "$i2c_dev" ]; then
			name=$(cat "$i2c_dev" 2>/dev/null)
			case "$name" in
				*fusb* | *FUSB* | *pi3usb* | *PI3USB* | *anx* | *ANX* | *hd3ss* | *HD3SS* | *tusb* | *TUSB*)
					found_usbc_controller=1
					devpath=$(dirname "$i2c_dev")
					echo "| $name | \`$devpath\` | USB-C Port Controller |"
					;;
			esac
		fi
	done 2>/dev/null

	if [ "$found_usbc_controller" = "0" ] && [ "$found_typec" = "0" ]; then
		echo "| *No USB-C controllers detected* | - | May still support USB-C video via DRM |"
	fi

	# Summary
	log_h3 "USB-C Video Support Summary"

	echo ""
	if [ "$found_typec" = "1" ]; then
		log_ok "USB Type-C subsystem detected - may support DisplayPort Alt Mode"
		log_info "Check for DP alternate modes above for video output capability"
	elif [ -d /sys/class/mhl ]; then
		log_ok "MHL support detected - can output video via MHL-to-HDMI adapter"
	else
		log_info "No USB-C video output subsystems detected"
		log_info "Device may still have USB-C port but without video capability"
		log_info "Check DRM subsystem for DisplayPort connectors"
	fi
}

###############################################################################
# SDL Library Detection
###############################################################################

fn_sdl_libraries() {
	log_h1 "SDL LIBRARIES"

	log_h2 "SDL Library Search"

	# Build search path from common locations + LD_LIBRARY_PATH
	SEARCH_PATHS="/lib /usr/lib /usr/local/lib /lib32 /usr/lib32 /lib64 /usr/lib64"
	if [ -n "$LD_LIBRARY_PATH" ]; then
		SEARCH_PATHS="$SEARCH_PATHS $(echo "$LD_LIBRARY_PATH" | tr ':' ' ')"
	fi

	found_sdl=0
	SDL1_FOUND=0
	SDL2_FOUND=0

	echo "| Library | Path |"
	echo "|---------|------|"

	# Search for SDL libraries
	for searchdir in $SEARCH_PATHS; do
		if [ -d "$searchdir" ]; then
			for lib in "$searchdir"/libSDL*.so* "$searchdir"/libSDL*.a; do
				if [ -f "$lib" ] && [ ! -L "$lib" ]; then
					found_sdl=1
					libname=$(basename "$lib")
					echo "| \`$libname\` | \`$searchdir\` |"

					# Track SDL version
					case "$libname" in
						libSDL2*) SDL2_FOUND=1 ;;
						libSDL-1.* | libSDL.so.1.*) SDL1_FOUND=1 ;;
					esac
				fi
			done 2>/dev/null
		fi
	done

	if [ "$found_sdl" = "0" ]; then
		echo "| *No SDL libraries found* | - |"
	fi

	log_h2 "SDL Version Summary"
	echo "| SDL Version | Status |"
	echo "|-------------|--------|"
	if [ "$SDL1_FOUND" = "1" ]; then
		echo "| SDL 1.2 | ✓ Found |"
	else
		echo "| SDL 1.2 | ✗ Not found |"
	fi
	if [ "$SDL2_FOUND" = "1" ]; then
		echo "| SDL 2.x | ✓ Found |"
	else
		echo "| SDL 2.x | ✗ Not found |"
	fi

	# Check for SDL modules/extensions
	log_h2 "SDL Modules/Extensions"
	echo "| Module | SDL 1.2 | SDL 2.x |"
	echo "|--------|---------|---------|"

	for mod in image ttf mixer net gfx; do
		sdl1_mod=""
		sdl2_mod=""

		for searchdir in $SEARCH_PATHS; do
			if [ -d "$searchdir" ]; then
				# Check for SDL 1.2 module (matches libSDL_module.so* and libSDL_module-*.so*)
				if ls "$searchdir"/libSDL_"$mod"*.so* >/dev/null 2>&1; then
					sdl1_mod="✓"
				fi
				# Check for SDL 2.x module (matches libSDL2_module.so* and libSDL2_module-*.so*)
				if ls "$searchdir"/libSDL2_"$mod"*.so* >/dev/null 2>&1; then
					sdl2_mod="✓"
				fi
			fi
		done 2>/dev/null

		[ -z "$sdl1_mod" ] && sdl1_mod="✗"
		[ -z "$sdl2_mod" ] && sdl2_mod="✗"

		echo "| SDL_$mod | $sdl1_mod | $sdl2_mod |"
	done

	# Try pkg-config for detailed version info
	log_h2 "pkg-config SDL Info"
	if command -v pkg-config >/dev/null 2>&1; then
		for sdl in sdl SDL sdl2 SDL2; do
			if pkg-config --exists "$sdl" 2>/dev/null; then
				version=$(pkg-config --modversion "$sdl" 2>/dev/null)
				cflags=$(pkg-config --cflags "$sdl" 2>/dev/null | cut -c1-60)
				log_ok "$sdl version: $version"
				log_info "CFLAGS: \`$cflags\`"
			fi
		done
	else
		log_info "pkg-config not available"
	fi
}

###############################################################################
# Binary Architecture Test
###############################################################################

fn_arch_test() {
	log_h1 "BINARY ARCHITECTURE TEST"

	log_h2 "System Architecture"
	echo "| Property | Value |"
	echo "|----------|-------|"
	echo "| uname -m | \`$(uname -m 2>/dev/null || echo 'N/A')\` |"

	# Check kernel config for multilib support
	if [ -f /proc/config.gz ]; then
		if zcat /proc/config.gz 2>/dev/null | grep -q "CONFIG_COMPAT=y"; then
			echo "| 32-bit compat | ✓ CONFIG_COMPAT=y |"
		else
			echo "| 32-bit compat | ✗ not enabled |"
		fi
	else
		echo "| 32-bit compat | *unknown (/proc/config.gz not available)* |"
	fi

	log_h2 "Dynamic Linker Detection"
	echo "| Linker | Type |"
	echo "|--------|------|"
	for dir in /lib /lib64 /lib32 /usr/lib /usr/lib64 /usr/lib32; do
		if [ -d "$dir" ]; then
			find "$dir" -maxdepth 1 -name 'ld-*' -type f 2>/dev/null | while read -r ld; do
				if command -v file >/dev/null 2>&1; then
					file_info=$(file "$ld" 2>/dev/null | sed 's/.*: //')
					[ -z "$file_info" ] && file_info="unknown"
				else
					file_info="(file command not available)"
				fi
				echo "| \`$ld\` | $file_info |"
			done
		fi
	done 2>/dev/null

	log_h2 "Architecture Detection (System Introspection)"

	# Get base architecture
	ARCH=$(uname -m 2>/dev/null || echo "unknown")
	IS_64BIT="no"
	IS_32BIT="no"
	HAS_32BIT_COMPAT="no"
	HAS_NEON="no"

	case "$ARCH" in
		aarch64 | arm64)
			IS_64BIT="yes"
			log_ok "Native architecture: **64-bit ARM (aarch64)**"
			;;
		armv7* | armv6* | arm*)
			IS_32BIT="yes"
			log_ok "Native architecture: **32-bit ARM ($ARCH)**"
			;;
		x86_64)
			IS_64BIT="yes"
			log_ok "Native architecture: **64-bit x86**"
			;;
		i?86)
			IS_32BIT="yes"
			log_ok "Native architecture: **32-bit x86 ($ARCH)**"
			;;
		*)
			log_warn "Unknown architecture: $ARCH"
			;;
	esac

	# Check for 32-bit compatibility on 64-bit systems
	log_h3 "32-bit Compatibility (on 64-bit systems)"
	if [ "$IS_64BIT" = "yes" ]; then
		# Method 1: Check kernel config
		if [ -f /proc/config.gz ]; then
			if zcat /proc/config.gz 2>/dev/null | grep -q "CONFIG_COMPAT=y"; then
				HAS_32BIT_COMPAT="yes"
				log_ok "Kernel CONFIG_COMPAT=y (32-bit syscall support)"
			else
				log_info "Kernel CONFIG_COMPAT not enabled"
			fi
		fi

		# Method 2: Check for 32-bit dynamic linkers
		for linker in /lib/ld-linux-armhf.so* /lib/ld-linux.so* /lib32/ld-linux* /usr/lib32/ld-linux*; do
			if [ -e "$linker" ]; then
				HAS_32BIT_COMPAT="yes"
				log_ok "32-bit linker found: \`$linker\`"
				break
			fi
		done 2>/dev/null

		# Method 3: Check for multilib directories
		for libdir in /lib32 /usr/lib32 /lib/arm-linux-gnueabihf; do
			if [ -d "$libdir" ]; then
				HAS_32BIT_COMPAT="yes"
				log_ok "32-bit library path found: \`$libdir\`"
				break
			fi
		done 2>/dev/null

		if [ "$HAS_32BIT_COMPAT" = "no" ]; then
			log_info "No 32-bit compatibility detected"
		fi
	else
		log_info "N/A (native 32-bit system)"
	fi

	# NEON/SIMD detection from /proc/cpuinfo
	log_h3 "NEON/SIMD Support"
	if [ -f /proc/cpuinfo ]; then
		CPU_FEATURES=$(grep -m1 "^Features" /proc/cpuinfo 2>/dev/null | cut -d: -f2 || echo "")

		if echo "$CPU_FEATURES" | grep -qw "neon"; then
			HAS_NEON="yes"
			log_ok "NEON detected in CPU features (32-bit ARM)"
		fi

		if echo "$CPU_FEATURES" | grep -qw "asimd"; then
			HAS_NEON="yes"
			log_ok "ASIMD (Advanced SIMD/NEON) detected in CPU features (64-bit ARM)"
		fi

		# Also check for other useful features
		log_info "CPU Features: \`$(echo "$CPU_FEATURES" | tr -s ' ')\`"

		if [ "$HAS_NEON" = "no" ]; then
			# Double-check via /proc/cpuinfo flags for x86
			if grep -q "sse\|avx" /proc/cpuinfo 2>/dev/null; then
				log_info "x86 SIMD detected (SSE/AVX)"
			else
				log_warn "No NEON/ASIMD detected in CPU features"
			fi
		fi
	else
		log_warn "/proc/cpuinfo not available"
	fi

	# Architecture Support Summary
	log_h3 "Architecture Support Summary"
	echo "| Capability | Status | Detection Method |"
	echo "|------------|--------|------------------|"

	if [ "$IS_64BIT" = "yes" ]; then
		echo "| 64-bit ARM (aarch64) | ✓ Native | uname -m |"
		if [ "$HAS_32BIT_COMPAT" = "yes" ]; then
			echo "| 32-bit ARM compat | ✓ Yes | CONFIG_COMPAT / linker |"
		else
			echo "| 32-bit ARM compat | ✗ No | CONFIG_COMPAT / linker |"
		fi
	elif [ "$IS_32BIT" = "yes" ]; then
		echo "| 32-bit ARM | ✓ Native | uname -m |"
		echo "| 64-bit ARM (aarch64) | ✗ No | (32-bit system) |"
	fi

	if [ "$HAS_NEON" = "yes" ]; then
		echo "| NEON/ASIMD SIMD | ✓ Yes | /proc/cpuinfo |"
	else
		echo "| NEON/ASIMD SIMD | ✗ No | /proc/cpuinfo |"
	fi

	log_h2 "System Binaries"
	if command -v file >/dev/null 2>&1; then
		echo "| Binary | Architecture |"
		echo "|--------|--------------|"
		for bin in /bin/sh /bin/ls /bin/cat /usr/bin/file /usr/bin/uname; do
			if [ -x "$bin" ]; then
				file_info=$(file "$bin" 2>/dev/null | sed 's/.*: //' | cut -c1-60)
				[ -z "$file_info" ] && file_info="unknown"
				echo "| \`$bin\` | $file_info |"
			fi
		done 2>/dev/null
	else
		log_info "file command not available - skipping binary analysis"
	fi
}

###############################################################################
# System Information
###############################################################################

fn_system() {
	log_h1 "SYSTEM INFORMATION"

	log_h2 "Basic Info"
	echo "| Property | Value |"
	echo "|----------|-------|"
	echo "| Hostname | \`$(hostname 2>/dev/null || echo 'N/A')\` |"
	echo "| Date | \`$(date 2>/dev/null || echo 'N/A')\` |"
	echo "| Uptime | \`$(uptime 2>/dev/null || echo 'N/A')\` |"

	log_h2 "Kernel"
	code_start
	uname -a 2>/dev/null || echo "uname failed"
	code_end

	log_h3 "Kernel Configuration"

	echo ""
	echo "| Property | Value |"
	echo "|----------|-------|"

	# Kernel HZ (timer frequency)
	kernel_hz=""
	if [ -f /proc/config.gz ]; then
		kernel_hz=$(zcat /proc/config.gz 2>/dev/null | grep "^CONFIG_HZ=" | cut -d= -f2)
	elif [ -f /boot/config-"$(uname -r)" ]; then
		kernel_hz=$(grep "^CONFIG_HZ=" /boot/config-"$(uname -r)" 2>/dev/null | cut -d= -f2)
	fi
	if [ -n "$kernel_hz" ]; then
		echo "| CONFIG_HZ | $kernel_hz Hz |"
	else
		echo "| CONFIG_HZ | *not detected* |"
	fi

	# High-resolution timers
	hrtimer=""
	if [ -f /proc/config.gz ]; then
		if zcat /proc/config.gz 2>/dev/null | grep -q "^CONFIG_HIGH_RES_TIMERS=y"; then
			hrtimer="enabled"
		elif zcat /proc/config.gz 2>/dev/null | grep -q "^# CONFIG_HIGH_RES_TIMERS is not set"; then
			hrtimer="disabled"
		fi
	fi
	if [ -n "$hrtimer" ]; then
		echo "| High-res timers | $hrtimer |"
	else
		echo "| High-res timers | *not detected* |"
	fi

	# Preemption model
	preempt=""
	if [ -f /proc/config.gz ]; then
		if zcat /proc/config.gz 2>/dev/null | grep -q "^CONFIG_PREEMPT_RT=y"; then
			preempt="PREEMPT_RT (real-time)"
		elif zcat /proc/config.gz 2>/dev/null | grep -q "^CONFIG_PREEMPT=y"; then
			preempt="PREEMPT (low-latency)"
		elif zcat /proc/config.gz 2>/dev/null | grep -q "^CONFIG_PREEMPT_VOLUNTARY=y"; then
			preempt="PREEMPT_VOLUNTARY"
		elif zcat /proc/config.gz 2>/dev/null | grep -q "^CONFIG_PREEMPT_NONE=y"; then
			preempt="PREEMPT_NONE (server)"
		fi
	fi
	if [ -n "$preempt" ]; then
		echo "| Preemption | $preempt |"
	else
		echo "| Preemption | *not detected* |"
	fi

	# Check actual timer resolution via /proc/timer_list
	if [ -f /proc/timer_list ]; then
		timer_res=$(grep "\.resolution:" /proc/timer_list 2>/dev/null | head -1 | awk '{print $2, $3}')
		if [ -n "$timer_res" ]; then
			echo "| Timer resolution | $timer_res |"
		fi
	fi

	log_h3 "OS Release"
	if [ -f /etc/os-release ]; then
		code_start
		cat /etc/os-release 2>/dev/null || true
		code_end
	fi

	if [ -f /etc/issue ]; then
		log_h3 "/etc/issue"
		code_start
		cat /etc/issue 2>/dev/null || true
		code_end
	fi

	log_h2 "Memory"

	# Extract key memory information
	echo "| Property | Value |"
	echo "|----------|-------|"

	if [ -f /proc/meminfo ]; then
		total_kb=$(grep "^MemTotal:" /proc/meminfo 2>/dev/null | awk '{print $2}')
		if [ -n "$total_kb" ]; then
			total_mb=$((total_kb / 1024))
			total_gb=$(echo "scale=2; $total_kb / 1048576" | bc 2>/dev/null || echo "")
			if [ -n "$total_gb" ]; then
				echo "| Total RAM | ${total_mb} MB (${total_gb} GB) |"
			else
				echo "| Total RAM | ${total_mb} MB |"
			fi
		fi

		avail_kb=$(grep "^MemAvailable:" /proc/meminfo 2>/dev/null | awk '{print $2}')
		if [ -n "$avail_kb" ]; then
			avail_mb=$((avail_kb / 1024))
			echo "| Available RAM | ${avail_mb} MB |"
		fi

		free_kb=$(grep "^MemFree:" /proc/meminfo 2>/dev/null | awk '{print $2}')
		if [ -n "$free_kb" ]; then
			free_mb=$((free_kb / 1024))
			echo "| Free RAM | ${free_mb} MB |"
		fi

		swap_kb=$(grep "^SwapTotal:" /proc/meminfo 2>/dev/null | awk '{print $2}')
		if [ -n "$swap_kb" ] && [ "$swap_kb" -gt 0 ]; then
			swap_mb=$((swap_kb / 1024))
			echo "| Swap | ${swap_mb} MB |"
		else
			echo "| Swap | disabled |"
		fi
	fi

	log_h3 "Memory Details"
	if [ -f /proc/meminfo ]; then
		code_start
		head -20 /proc/meminfo 2>/dev/null || true
		code_end
	fi

	if command -v free >/dev/null 2>&1; then
		log_h3 "Free Memory"
		code_start
		free -m 2>/dev/null || true
		code_end
	fi

	log_h2 "Storage"

	log_h3 "Storage Device Enumeration"

	# Detect all MMC/SD card devices
	echo ""
	echo "| Device | Type | Size | Model | Partitions |"
	echo "|--------|------|------|-------|------------|"

	found_storage=0
	# Find all block devices (avoid glob expansion issues with explicit loop)
	for dev in /dev/mmcblk[0-9] /dev/sd[a-z]; do
		# Skip if glob didn't expand (literal path with brackets)
		[ -e "$dev" ] || continue

		# Verify it's a block device
		[ -b "$dev" ] || continue

		# Skip special MMC partitions (rpmb, boot0, boot1)
		echo "$dev" | grep -q 'rpmb\|boot[0-9]' && continue

		found_storage=1
		devname=$(basename "$dev")

		# Determine device type
		device_type="unknown"
		if echo "$dev" | grep -q "mmcblk"; then
			# Check if it's eMMC or SD card
			if [ -f "/sys/block/$devname/device/type" ]; then
				mmc_type=$(cat "/sys/block/$devname/device/type" 2>/dev/null)
				case "$mmc_type" in
					MMC) device_type="eMMC" ;;
					SD) device_type="SD Card" ;;
					*) device_type="MMC ($mmc_type)" ;;
				esac
			else
				device_type="MMC/SD"
			fi
		elif echo "$dev" | grep -q "sd"; then
			device_type="USB/SATA"
		fi

		# Get size
		size_bytes=""
		size_human=""
		if [ -f "/sys/block/$devname/size" ]; then
			size_blocks=$(cat "/sys/block/$devname/size" 2>/dev/null)
			if [ -n "$size_blocks" ] && [ "$size_blocks" -gt 0 ]; then
				# Convert 512-byte blocks to GB
				size_bytes=$((size_blocks * 512))
				size_gb=$((size_bytes / 1000000000))
				if [ "$size_gb" -gt 0 ]; then
					size_human="${size_gb}GB"
				else
					size_mb=$((size_bytes / 1000000))
					size_human="${size_mb}MB"
				fi
			fi
		fi
		[ -z "$size_human" ] && size_human="N/A"

		# Get model/name
		model=""
		if [ -f "/sys/block/$devname/device/name" ]; then
			model=$(cat "/sys/block/$devname/device/name" 2>/dev/null | tr -d '\0')
		elif [ -f "/sys/block/$devname/device/model" ]; then
			model=$(cat "/sys/block/$devname/device/model" 2>/dev/null | tr -d ' \t')
		fi
		[ -z "$model" ] && model="unknown"

		# List partitions
		partitions=""
		for part in "$dev"p* "$dev"[0-9]; do
			if [ -b "$part" ]; then
				partname=$(basename "$part")
				if [ -z "$partitions" ]; then
					partitions="$partname"
				else
					partitions="$partitions, $partname"
				fi
			fi
		done 2>/dev/null
		[ -z "$partitions" ] && partitions="none"

		echo "| \`$dev\` | $device_type | $size_human | $model | $partitions |"
	done 2>/dev/null

	if [ "$found_storage" = "0" ]; then
		echo "| *No block devices found* | - | - | - | - |"
	fi

	log_h3 "Boot Device Detection"

	# Find root filesystem device
	root_device=$(findmnt -n -o SOURCE / 2>/dev/null || grep " / " /proc/mounts 2>/dev/null | awk '{print $1}' | head -1)

	echo ""
	echo "| Property | Value |"
	echo "|----------|-------|"

	if [ -n "$root_device" ]; then
		echo "| Root filesystem | \`$root_device\` |"

		# Determine boot media type
		boot_type="unknown"
		if echo "$root_device" | grep -q "mmcblk0"; then
			# mmcblk0 is usually eMMC on devices with both eMMC and SD
			if [ -f "/sys/block/mmcblk0/device/type" ]; then
				mmc_type=$(cat "/sys/block/mmcblk0/device/type" 2>/dev/null)
				case "$mmc_type" in
					MMC) boot_type="eMMC (mmcblk0)" ;;
					SD) boot_type="SD Card (mmcblk0)" ;;
					*) boot_type="MMC/SD (mmcblk0)" ;;
				esac
			else
				boot_type="eMMC/SD (mmcblk0)"
			fi
		elif echo "$root_device" | grep -q "mmcblk1"; then
			boot_type="SD Card (mmcblk1)"
		elif echo "$root_device" | grep -q "sd"; then
			boot_type="USB/SATA"
		elif echo "$root_device" | grep -q "ubi"; then
			boot_type="NAND/UBI"
		elif echo "$root_device" | grep -q "mtd"; then
			boot_type="NOR/MTD"
		fi

		echo "| Boot media type | $boot_type |"
	else
		echo "| Root filesystem | *not detected* |"
		echo "| Boot media type | *unknown* |"
	fi

	# Check for additional SD card slots
	log_h3 "Secondary Storage Detection"

	echo ""
	echo "| Mount Point | Device | Type | Size |"
	echo "|-------------|--------|------|------|"

	found_secondary=0
	for mount_point in /mnt/* /media/* /storage/*; do
		# Skip if glob didn't match anything (literal path with asterisk)
		[ -e "$mount_point" ] || continue

		# Check if it's a mount point (fallback to /proc/mounts if mountpoint cmd missing)
		is_mounted=0
		if command -v mountpoint >/dev/null 2>&1; then
			mountpoint -q "$mount_point" 2>/dev/null && is_mounted=1
		else
			# Fallback: check /proc/mounts directly
			grep -q " $mount_point " /proc/mounts 2>/dev/null && is_mounted=1
		fi

		if [ "$is_mounted" = "1" ]; then
			found_secondary=1
			mount_dev=$(findmnt -n -o SOURCE "$mount_point" 2>/dev/null || grep " $mount_point " /proc/mounts 2>/dev/null | awk '{print $1}')
			mount_type=$(findmnt -n -o FSTYPE "$mount_point" 2>/dev/null || grep " $mount_point " /proc/mounts 2>/dev/null | awk '{print $3}')
			mount_size=$(df -h "$mount_point" 2>/dev/null | awk 'NR==2 {print $2}')
			[ -z "$mount_dev" ] && mount_dev="unknown"
			[ -z "$mount_type" ] && mount_type="unknown"
			[ -z "$mount_size" ] && mount_size="N/A"
			echo "| \`$mount_point\` | \`$mount_dev\` | $mount_type | $mount_size |"
		fi
	done 2>/dev/null

	if [ "$found_secondary" = "0" ]; then
		log_info "No secondary storage mounted at /mnt/*, /media/*, or /storage/*"
	fi

	log_h3 "Disk Usage"
	code_start
	df -h 2>/dev/null || echo "df not available"
	code_end

	log_h3 "Mount Points (detailed)"
	code_start
	mount 2>/dev/null | head -30 || true
	code_end

	log_h3 "Block Devices (lsblk)"
	code_start
	lsblk 2>/dev/null || ls -la /dev/mmcblk* /dev/sd* 2>/dev/null || echo "lsblk not available"
	code_end

	log_h2 "Processes (top 30)"
	code_start
	ps aux 2>/dev/null | head -30 || ps 2>/dev/null | head -30 || echo "ps not available"
	code_end
}

###############################################################################
# Hardware Paths
###############################################################################

fn_hardware() {
	log_h1 "HARDWARE PATHS"

	log_h2 "Thermal Zones"
	found_tz=0
	for tz in /sys/class/thermal/thermal_zone*; do
		if [ -d "$tz" ]; then
			if [ "$found_tz" = "0" ]; then
				echo "| Zone | Type | Temperature |"
				echo "|------|------|-------------|"
				found_tz=1
			fi
			name=$(cat "$tz/type" 2>/dev/null || echo "unknown")
			temp=$(cat "$tz/temp" 2>/dev/null || echo "N/A")
			echo "| \`$tz\` | $name | ${temp} mC |"
		fi
	done 2>/dev/null
	if [ "$found_tz" = "0" ]; then
		log_info "No thermal zones found"
	fi

	log_h2 "Power Supply"
	for ps in /sys/class/power_supply/*; do
		if [ -d "$ps" ]; then
			log_h3 "$(basename "$ps")"
			echo "| Property | Value |"
			echo "|----------|-------|"
			for f in type status capacity voltage_now current_now online; do
				if [ -f "$ps/$f" ]; then
					echo "| $f | \`$(cat "$ps/$f" 2>/dev/null || echo 'N/A')\` |"
				fi
			done
		fi
	done 2>/dev/null

	log_h2 "Backlight"
	for bl in /sys/class/backlight/*; do
		if [ -d "$bl" ]; then
			log_h3 "$(basename "$bl")"
			echo "| Property | Value |"
			echo "|----------|-------|"
			for f in brightness max_brightness actual_brightness; do
				if [ -f "$bl/$f" ]; then
					echo "| $f | \`$(cat "$bl/$f" 2>/dev/null || echo 'N/A')\` |"
				fi
			done
		fi
	done 2>/dev/null

	log_h2 "Input Devices"
	found_input=0
	for ev in /dev/input/event*; do
		if [ -e "$ev" ]; then
			if [ "$found_input" = "0" ]; then
				echo "| Device | Name |"
				echo "|--------|------|"
				found_input=1
			fi
			num=$(basename "$ev" | sed 's/event//')
			name=$(cat "/sys/class/input/event$num/device/name" 2>/dev/null || echo "unknown")
			echo "| \`$ev\` | $name |"
		fi
	done 2>/dev/null
	if [ "$found_input" = "0" ]; then
		log_info "No input devices found"
	fi

	# Detailed input capabilities via sysfs
	log_h2 "Input Device Capabilities"
	for ev in /sys/class/input/event*; do
		if [ -d "$ev" ]; then
			evname=$(basename "$ev")
			devname=$(cat "$ev/device/name" 2>/dev/null || echo "unknown")
			log_h3 "$evname: $devname"

			# Check capabilities bitmasks
			capdir="$ev/device/capabilities"
			if [ -d "$capdir" ]; then
				echo "| Capability | Bitmask |"
				echo "|------------|---------|"
				for cap in ev key rel abs; do
					if [ -f "$capdir/$cap" ]; then
						val=$(cat "$capdir/$cap" 2>/dev/null || echo "0")
						if [ "$val" != "0" ]; then
							echo "| $cap | \`$val\` |"
						fi
					fi
				done
			fi

			# Check for joystick-specific info
			jsdir="$ev/device"
			if [ -f "$jsdir/id/vendor" ]; then
				vid=$(cat "$jsdir/id/vendor" 2>/dev/null || echo "N/A")
				pid=$(cat "$jsdir/id/product" 2>/dev/null || echo "N/A")
				echo ""
				echo "- Vendor ID: \`$vid\`, Product ID: \`$pid\`"
			fi
		fi
	done 2>/dev/null

	log_h2 "Joystick Devices"
	echo "| Device | Exists |"
	echo "|--------|--------|"
	for js in /dev/input/js0 /dev/input/js1 /dev/input/js2; do
		if [ -e "$js" ]; then
			echo "| \`$js\` | ✓ |"
		fi
	done 2>/dev/null
	if [ ! -e /dev/input/js0 ]; then
		echo "| /dev/input/js* | *none found* |"
	fi

	log_h2 "GPIO"
	if [ -d /sys/class/gpio ]; then
		code_start
		ls -la /sys/class/gpio/ 2>/dev/null || true
		code_end
	else
		log_info "No GPIO sysfs"
	fi

	log_h2 "LEDs"
	if [ -d /sys/class/leds ]; then
		echo "| LED | Brightness |"
		echo "|-----|------------|"
		for led in /sys/class/leds/*; do
			if [ -d "$led" ]; then
				echo "| $(basename "$led") | \`$(cat "$led/brightness" 2>/dev/null || echo 'N/A')\` |"
			fi
		done 2>/dev/null
	else
		log_info "No LEDs sysfs"
	fi

	log_h2 "Vibration/Rumble"
	echo "| Path | Value |"
	echo "|------|-------|"
	found_rumble=0
	for path in /sys/class/power_supply/*/moto \
		/sys/class/gpio/gpio*/value \
		/sys/class/timed_output/vibrator/enable; do
		if [ -e "$path" ]; then
			found_rumble=1
			echo "| \`$path\` | \`$(cat "$path" 2>/dev/null || echo '[no read]')\` |"
		fi
	done 2>/dev/null
	if [ "$found_rumble" = "0" ]; then
		echo "| *No rumble paths found* | - |"
	fi

	log_h2 "RTC (Real Time Clock)"
	if [ -d /sys/class/rtc ]; then
		echo "| RTC | Time | Date |"
		echo "|-----|------|------|"
		for rtc in /sys/class/rtc/*; do
			if [ -d "$rtc" ]; then
				rtcname=$(basename "$rtc")
				rtctime=$(cat "$rtc/time" 2>/dev/null || echo "N/A")
				rtcdate=$(cat "$rtc/date" 2>/dev/null || echo "N/A")
				echo "| $rtcname | \`$rtctime\` | \`$rtcdate\` |"
			fi
		done 2>/dev/null
	else
		log_info "No RTC sysfs"
	fi

	log_h2 "Voltage Regulators"
	if [ -d /sys/class/regulator ]; then
		echo "| Regulator | State | Voltage (uV) |"
		echo "|-----------|-------|--------------|"
		for reg in /sys/class/regulator/regulator.*; do
			if [ -d "$reg" ]; then
				name=$(cat "$reg/name" 2>/dev/null || basename "$reg")
				state=$(cat "$reg/state" 2>/dev/null || echo "N/A")
				uv=$(cat "$reg/microvolts" 2>/dev/null || echo "N/A")
				echo "| $name | $state | $uv |"
			fi
		done 2>/dev/null | head -20
	else
		log_info "No regulator sysfs"
	fi

	log_h2 "Clocksource"
	if [ -d /sys/devices/system/clocksource/clocksource0 ]; then
		echo "| Property | Value |"
		echo "|----------|-------|"
		echo "| current | \`$(cat /sys/devices/system/clocksource/clocksource0/current_clocksource 2>/dev/null || echo 'N/A')\` |"
		echo "| available | \`$(cat /sys/devices/system/clocksource/clocksource0/available_clocksource 2>/dev/null || echo 'N/A')\` |"
	else
		log_info "No clocksource sysfs"
	fi

	log_h2 "Hardware Watchdog"

	# Check for watchdog devices
	found_watchdog=0
	echo ""
	echo "| Device | Driver | Timeout | Status |"
	echo "|--------|--------|---------|--------|"

	for wd in /dev/watchdog*; do
		if [ -c "$wd" ]; then
			found_watchdog=1
			wdname=$(basename "$wd")

			# Try to find corresponding sysfs entry
			driver=""
			timeout=""
			status=""

			# Check /sys/class/watchdog
			if [ -d /sys/class/watchdog/"$wdname" ]; then
				if [ -f /sys/class/watchdog/"$wdname"/identity ]; then
					driver=$(cat /sys/class/watchdog/"$wdname"/identity 2>/dev/null)
				fi
				if [ -f /sys/class/watchdog/"$wdname"/timeout ]; then
					timeout=$(cat /sys/class/watchdog/"$wdname"/timeout 2>/dev/null)
					[ -n "$timeout" ] && timeout="${timeout}s"
				fi
				if [ -f /sys/class/watchdog/"$wdname"/state ]; then
					status=$(cat /sys/class/watchdog/"$wdname"/state 2>/dev/null)
				fi
			fi

			[ -z "$driver" ] && driver="unknown"
			[ -z "$timeout" ] && timeout="N/A"
			[ -z "$status" ] && status="unknown"

			echo "| \`$wd\` | $driver | $timeout | $status |"
		fi
	done 2>/dev/null

	if [ "$found_watchdog" = "0" ]; then
		echo "| *No watchdog devices found* | - | - | - |"
	else
		log_info "Watchdog devices present (may prevent system hangs)"
	fi
}

###############################################################################
# Special Hardware Features (Platform-Specific)
###############################################################################

fn_special_hardware() {
	log_h1 "SPECIAL HARDWARE FEATURES"

	log_h2 "PMIC (Power Management IC) Detection"
	echo "| PMIC Type | Path | Present |"
	echo "|-----------|------|---------|"

	# AXP PMICs (common in Allwinner devices)
	found_pmic=0
	for pmic_path in /sys/class/power_supply/axp*; do
		if [ -d "$pmic_path" ]; then
			found_pmic=1
			echo "| AXP Series ($(basename "$pmic_path")) | \`$pmic_path\` | ✓ |"
		fi
	done 2>/dev/null

	# Check I2C for known PMICs
	for i2c_pmic in /sys/bus/i2c/devices/*/name; do
		if [ -f "$i2c_pmic" ]; then
			name=$(cat "$i2c_pmic" 2>/dev/null)
			case "$name" in
				*axp* | *AXP* | *rk8* | *RK8* | *act8* | *ACT8* | *tps* | *TPS*)
					found_pmic=1
					devpath=$(dirname "$i2c_pmic")
					echo "| $name | \`$devpath\` | ✓ |"
					;;
			esac
		fi
	done 2>/dev/null

	if [ "$found_pmic" = "0" ]; then
		echo "| *Unknown* | - | GPIO-based or not detected |"
	fi

	# SAR ADC (used on some Miyoo Mini variants for battery)
	log_h2 "SAR ADC (Battery ADC)"
	if [ -d /sys/class/saradc ]; then
		log_ok "SAR ADC found"
		code_start
		ls -la /sys/class/saradc/ 2>/dev/null || true
		code_end
	elif [ -f /sys/bus/iio/devices/iio:device0/in_voltage0_raw ]; then
		log_ok "IIO ADC device found"
		echo "- Raw voltage: \`$(cat /sys/bus/iio/devices/iio:device0/in_voltage0_raw 2>/dev/null || echo 'N/A')\`"
	else
		log_info "No SAR ADC / IIO ADC found"
	fi

	log_h2 "Lid/Hall Sensor"
	echo "| Path | Value |"
	echo "|------|-------|"
	found_lid=0
	for lid_path in \
		/sys/devices/soc0/soc/soc:hall-mh248/hallvalue \
		/sys/devices/platform/hall/hallvalue \
		/sys/class/switch/lid/state \
		/proc/driver/hall; do
		if [ -e "$lid_path" ]; then
			found_lid=1
			echo "| \`$lid_path\` | \`$(cat "$lid_path" 2>/dev/null || echo '[no read]')\` |"
		fi
	done 2>/dev/null
	if [ "$found_lid" = "0" ]; then
		echo "| *No lid sensor found* | - |"
	fi

	log_h2 "Hardware Acceleration"
	echo "| Feature | Path | Present |"
	echo "|---------|------|---------|"

	# Miyoo Mini MI_GFX
	if [ -e /dev/mi_gfx ]; then
		echo "| MI_GFX (Miyoo) | \`/dev/mi_gfx\` | ✓ |"
	fi
	if [ -d /dev/mi_sys ]; then
		echo "| MI_SYS (Miyoo) | \`/dev/mi_sys\` | ✓ |"
	fi

	# Mali GPU device
	if [ -e /dev/mali ] || [ -e /dev/mali0 ]; then
		echo "| Mali GPU | \`/dev/mali*\` | ✓ |"
	fi

	# DRI/DRM render nodes
	for render in /dev/dri/renderD*; do
		if [ -e "$render" ]; then
			echo "| DRI Render | \`$render\` | ✓ |"
		fi
	done 2>/dev/null

	# Video codec devices
	for codec in /dev/video* /dev/cedar* /dev/rkvdec /dev/rkvenc /dev/mpp_service; do
		if [ -e "$codec" ]; then
			echo "| Video Codec | \`$codec\` | ✓ |"
		fi
	done 2>/dev/null

	log_h2 "Touchscreen"
	found_ts=0
	for ts in /dev/input/touchscreen* /sys/class/input/*/device/name; do
		if [ -e "$ts" ]; then
			if [ -f "$ts" ]; then
				name=$(cat "$ts" 2>/dev/null)
				case "$name" in
					*touch* | *Touch* | *ts* | *TS* | *ft5* | *gt9* | *goodix*)
						found_ts=1
						echo "- Touchscreen: $name"
						;;
				esac
			else
				found_ts=1
				echo "- Touchscreen device: \`$ts\`"
			fi
		fi
	done 2>/dev/null
	if [ "$found_ts" = "0" ]; then
		log_info "No touchscreen detected"
	fi

	log_h2 "Analog Stick ADC"
	# Check for analog stick ADC paths (common on handhelds)
	echo "| Path | Value |"
	echo "|------|-------|"
	found_analog=0
	for adc_path in \
		/sys/bus/iio/devices/iio:device*/in_voltage*_raw \
		/sys/class/saradc/ch* \
		/sys/devices/platform/*/adc/in_voltage*_raw; do
		if [ -e "$adc_path" ]; then
			# Only show first few to avoid spam
			if [ "$found_analog" -lt 8 ]; then
				found_analog=$((found_analog + 1))
				echo "| \`$adc_path\` | \`$(cat "$adc_path" 2>/dev/null || echo 'N/A')\` |"
			fi
		fi
	done 2>/dev/null
	if [ "$found_analog" = "0" ]; then
		echo "| *No analog ADC paths found* | - |"
	fi
}

###############################################################################
# Environment Variables
###############################################################################

fn_environment() {
	log_h1 "ENVIRONMENT"

	log_h2 "LessUI Environment Variables"
	echo "| Variable | Value |"
	echo "|----------|-------|"
	echo "| PLATFORM | \`${PLATFORM:-unset}\` |"
	echo "| SDCARD_PATH | \`${SDCARD_PATH:-unset}\` |"
	echo "| SYSTEM_PATH | \`${SYSTEM_PATH:-unset}\` |"
	echo "| USERDATA_PATH | \`${USERDATA_PATH:-unset}\` |"
	echo "| LOGS_PATH | \`${LOGS_PATH:-unset}\` |"
	echo "| SHARED_USERDATA_PATH | \`${SHARED_USERDATA_PATH:-unset}\` |"

	log_h2 "All Environment Variables"
	code_start
	env 2>/dev/null | sort || true
	code_end

	log_h2 "PATH Components"
	code_start
	echo "$PATH" | tr ':' '\n'
	code_end
}

###############################################################################
# Power Management
###############################################################################

fn_power_management() {
	log_h1 "POWER MANAGEMENT"

	log_h2 "Sleep States"

	# Check what sleep states the kernel supports
	if [ -f /sys/power/state ]; then
		STATES=$(cat /sys/power/state 2>/dev/null)
		log_ok "Supported states: \`$STATES\`"

		echo ""
		echo "| State | Description | Supported |"
		echo "|-------|-------------|-----------|"

		if echo "$STATES" | grep -qw "mem"; then
			echo "| mem | Suspend-to-RAM (deep sleep) | ✓ |"
		else
			echo "| mem | Suspend-to-RAM (deep sleep) | ✗ |"
		fi

		if echo "$STATES" | grep -qw "standby"; then
			echo "| standby | Power-On Suspend (light sleep) | ✓ |"
		else
			echo "| standby | Power-On Suspend (light sleep) | ✗ |"
		fi

		if echo "$STATES" | grep -qw "freeze"; then
			echo "| freeze | Suspend-to-Idle (s2idle) | ✓ |"
		else
			echo "| freeze | Suspend-to-Idle (s2idle) | ✗ |"
		fi

		if echo "$STATES" | grep -qw "disk"; then
			echo "| disk | Suspend-to-Disk (hibernate) | ✓ |"
		else
			echo "| disk | Suspend-to-Disk (hibernate) | ✗ |"
		fi
	else
		log_warn "/sys/power/state not found - kernel power management not available"
	fi

	# Memory sleep modes (kernel 4.x+)
	log_h2 "Memory Sleep Configuration"
	if [ -f /sys/power/mem_sleep ]; then
		MEM_SLEEP=$(cat /sys/power/mem_sleep 2>/dev/null)
		log_info "mem_sleep modes: \`$MEM_SLEEP\`"
		log_info "(bracketed value is currently active)"
	else
		log_info "/sys/power/mem_sleep not available"
	fi

	# PM debug/test mode
	if [ -f /sys/power/pm_test ]; then
		PM_TEST=$(cat /sys/power/pm_test 2>/dev/null)
		log_info "pm_test modes: \`$PM_TEST\`"
	fi

	log_h2 "Suspend Write Test"
	log_info "Testing if we can write to /sys/power/state..."

	if [ -f /sys/power/state ]; then
		# Test if file is writable (don't actually suspend!)
		if [ -w /sys/power/state ]; then
			log_ok "/sys/power/state is writable - suspend should work"
		else
			log_fail "/sys/power/state is NOT writable - suspend will fail"
			log_info "May need root privileges or kernel support"
		fi
	fi

	log_h2 "Wakeup Sources"
	log_info "Devices that can wake the system from suspend:"

	# Check wakeup-capable devices
	found_wakeup=0
	echo ""
	echo "| Device | Wakeup Enabled | Count |"
	echo "|--------|----------------|-------|"

	for wakeup in /sys/devices/*/power/wakeup /sys/devices/*/*/power/wakeup /sys/devices/*/*/*/power/wakeup; do
		if [ -f "$wakeup" ]; then
			enabled=$(cat "$wakeup" 2>/dev/null)
			if [ "$enabled" = "enabled" ]; then
				found_wakeup=$((found_wakeup + 1))
				devpath=$(dirname "$(dirname "$wakeup")")
				devname=$(basename "$devpath")

				# Get wakeup count if available
				countfile="$(dirname "$wakeup")/wakeup_count"
				if [ -f "$countfile" ]; then
					count=$(cat "$countfile" 2>/dev/null || echo "N/A")
				else
					count="-"
				fi

				# Limit output to most relevant devices
				if [ "$found_wakeup" -le 20 ]; then
					echo "| $devname | ✓ enabled | $count |"
				fi
			fi
		fi
	done 2>/dev/null

	if [ "$found_wakeup" = "0" ]; then
		echo "| *No wakeup sources found* | - | - |"
	elif [ "$found_wakeup" -gt 20 ]; then
		echo "| ... | ($found_wakeup total) | ... |"
	fi

	# RTC wakeup (for alarm-based wake)
	log_h2 "RTC Wakeup (Alarm Wake)"
	for rtc in /sys/class/rtc/rtc*; do
		if [ -d "$rtc" ]; then
			rtcname=$(basename "$rtc")
			wakealarm=""
			wakeup_enabled=""

			if [ -f "$rtc/wakealarm" ]; then
				wakealarm=$(cat "$rtc/wakealarm" 2>/dev/null)
				[ -z "$wakealarm" ] && wakealarm="not set"
			fi

			if [ -f "$rtc/device/power/wakeup" ]; then
				wakeup_enabled=$(cat "$rtc/device/power/wakeup" 2>/dev/null)
			fi

			echo "| Property | Value |"
			echo "|----------|-------|"
			echo "| RTC | $rtcname |"
			echo "| Wake alarm | \`$wakealarm\` |"
			echo "| Wakeup enabled | $wakeup_enabled |"
		fi
	done 2>/dev/null

	# PM runtime status
	log_h2 "PM Runtime Status"
	log_info "Runtime power management allows devices to suspend independently."

	pm_runtime_enabled=0
	pm_runtime_suspended=0

	for status in /sys/devices/*/power/runtime_status /sys/devices/*/*/power/runtime_status; do
		if [ -f "$status" ]; then
			state=$(cat "$status" 2>/dev/null)
			pm_runtime_enabled=$((pm_runtime_enabled + 1))
			if [ "$state" = "suspended" ]; then
				pm_runtime_suspended=$((pm_runtime_suspended + 1))
			fi
		fi
	done 2>/dev/null

	echo ""
	echo "| Metric | Value |"
	echo "|--------|-------|"
	echo "| Devices with PM runtime | $pm_runtime_enabled |"
	echo "| Currently suspended | $pm_runtime_suspended |"

	# Suspend statistics (if available)
	log_h2 "Suspend Statistics"
	if [ -d /sys/power ]; then
		echo "| Statistic | Value |"
		echo "|-----------|-------|"

		for stat in suspend_stats/success suspend_stats/fail pm_async pm_freeze_timeout; do
			if [ -f "/sys/power/$stat" ]; then
				val=$(cat "/sys/power/$stat" 2>/dev/null || echo "N/A")
				echo "| $stat | \`$val\` |"
			fi
		done

		# Show last failed step if available
		if [ -f /sys/power/suspend_stats/last_failed_step ]; then
			failed_step=$(cat /sys/power/suspend_stats/last_failed_step 2>/dev/null)
			if [ -n "$failed_step" ] && [ "$failed_step" != "none" ]; then
				log_warn "Last failed suspend step: $failed_step"
			fi
		fi
	fi

	# CPU idle states (C-states)
	log_h2 "CPU Idle States"
	if [ -d /sys/devices/system/cpu/cpu0/cpuidle ]; then
		log_ok "cpuidle driver present"

		echo ""
		echo "| State | Name | Latency (µs) | Residency (µs) | Usage |"
		echo "|-------|------|--------------|----------------|-------|"

		for state in /sys/devices/system/cpu/cpu0/cpuidle/state*; do
			if [ -d "$state" ]; then
				name=$(cat "$state/name" 2>/dev/null || echo "?")
				latency=$(cat "$state/latency" 2>/dev/null || echo "?")
				residency=$(cat "$state/residency" 2>/dev/null || echo "?")
				usage=$(cat "$state/usage" 2>/dev/null || echo "?")
				sname=$(basename "$state")
				echo "| $sname | $name | $latency | $residency | $usage |"
			fi
		done 2>/dev/null

		# Show current driver
		if [ -f /sys/devices/system/cpu/cpuidle/current_driver ]; then
			driver=$(cat /sys/devices/system/cpu/cpuidle/current_driver 2>/dev/null)
			log_info "cpuidle driver: \`$driver\`"
		fi
	else
		log_info "cpuidle not available"
	fi

	# Kernel config hints
	log_h2 "Kernel Power Config"
	if [ -f /proc/config.gz ]; then
		log_info "Checking kernel config for power management options..."

		echo ""
		echo "| Config | Status |"
		echo "|--------|--------|"

		for cfg in CONFIG_SUSPEND CONFIG_PM_SLEEP CONFIG_PM_WAKELOCKS CONFIG_HIBERNATION \
			CONFIG_PM_AUTOSLEEP CONFIG_PM_DEBUG CONFIG_CPU_IDLE; do
			if zcat /proc/config.gz 2>/dev/null | grep -q "^$cfg=y"; then
				echo "| $cfg | ✓ enabled |"
			elif zcat /proc/config.gz 2>/dev/null | grep -q "^$cfg=m"; then
				echo "| $cfg | ○ module |"
			elif zcat /proc/config.gz 2>/dev/null | grep -q "^# $cfg is not set"; then
				echo "| $cfg | ✗ disabled |"
			fi
		done
	else
		log_info "/proc/config.gz not available - cannot check kernel config"
	fi

	# Summary
	log_h2 "Power Management Summary"

	has_suspend="no"
	has_deep_sleep="no"
	has_wakeup="no"
	writable="no"

	if [ -f /sys/power/state ]; then
		has_suspend="yes"
		if cat /sys/power/state 2>/dev/null | grep -qw "mem"; then
			has_deep_sleep="yes"
		fi
		if [ -w /sys/power/state ]; then
			writable="yes"
		fi
	fi

	if [ "$found_wakeup" -gt 0 ]; then
		has_wakeup="yes"
	fi

	echo ""
	echo "| Capability | Status |"
	echo "|------------|--------|"
	if [ "$has_suspend" = "yes" ]; then
		echo "| Power state interface | ✓ Present |"
	else
		echo "| Power state interface | ✗ Missing |"
	fi
	if [ "$has_deep_sleep" = "yes" ]; then
		echo "| Suspend-to-RAM (mem) | ✓ Supported |"
	else
		echo "| Suspend-to-RAM (mem) | ✗ Not available |"
	fi
	if [ "$writable" = "yes" ]; then
		echo "| Write access | ✓ Writable |"
	else
		echo "| Write access | ✗ Permission denied |"
	fi
	if [ "$has_wakeup" = "yes" ]; then
		echo "| Wakeup sources | ✓ $found_wakeup devices |"
	else
		echo "| Wakeup sources | ⚠ None configured |"
	fi

	# Final verdict
	echo ""
	if [ "$has_deep_sleep" = "yes" ] && [ "$writable" = "yes" ] && [ "$has_wakeup" = "yes" ]; then
		log_ok "**Deep sleep should work** - all requirements met"
	elif [ "$has_deep_sleep" = "yes" ] && [ "$writable" = "yes" ]; then
		log_warn "Deep sleep available but no wakeup sources detected"
	elif [ "$has_deep_sleep" = "yes" ]; then
		log_warn "Deep sleep supported but /sys/power/state not writable"
	else
		log_warn "Deep sleep (suspend-to-RAM) not available on this kernel"
	fi
}

###############################################################################
# Network (brief)
###############################################################################

fn_network() {
	log_h1 "NETWORK"

	log_h2 "Interfaces"
	code_start
	safe_ifconfig 2>/dev/null || ip addr 2>/dev/null || echo "No network tools available"
	code_end

	log_h2 "WiFi Status"

	# Probe wireless tools once to avoid repeated timeouts if driver is stuck
	iw_works=0
	iwconfig_works=0
	wpa_works=0

	if command -v iw >/dev/null 2>&1; then
		if safe_iw dev 2>/dev/null | grep -q .; then
			iw_works=1
		else
			log_warn "iw command timed out or failed - skipping detailed wireless info"
		fi
	elif command -v iwconfig >/dev/null 2>&1; then
		# Fallback to iwconfig for older/vendor drivers
		if safe_iwconfig 2>/dev/null | grep -q "wlan\|802\.11"; then
			iwconfig_works=1
			log_info "Using iwconfig (iw not available)"
		else
			log_warn "iwconfig timed out or failed"
		fi
	else
		log_info "No wireless tools available (iw/iwconfig not found)"
	fi

	if command -v wpa_cli >/dev/null 2>&1; then
		if safe_wpa_cli status 2>/dev/null | grep -q .; then
			wpa_works=1
		else
			log_warn "wpa_cli timed out or failed - skipping wpa_supplicant info"
		fi
	fi

	# Find all WiFi interfaces (not just wlan0)
	found_wifi=0
	for iface in /sys/class/net/*; do
		if [ -d "$iface/wireless" ] || [ -L "$iface/phy80211" ]; then
			found_wifi=1
			ifname=$(basename "$iface")

			log_h3 "$ifname"
			echo "| Property | Value |"
			echo "|----------|-------|"

			# Basic interface info (from sysfs - always safe)
			if [ -f "$iface/operstate" ]; then
				echo "| operstate | \`$(cat "$iface/operstate" 2>/dev/null || echo 'N/A')\` |"
			fi
			if [ -f "$iface/address" ]; then
				echo "| MAC address | \`$(cat "$iface/address" 2>/dev/null || echo 'N/A')\` |"
			fi

			# WiFi driver detection
			driver=""
			if [ -L "$iface/device/driver" ]; then
				driver=$(basename "$(readlink "$iface/device/driver" 2>/dev/null)" || echo "")
			fi
			if [ -n "$driver" ]; then
				echo "| driver | \`$driver\` |"
			fi

			# Chipset identification via USB vendor/product
			if [ -f "$iface/device/uevent" ]; then
				vendor=$(grep "PRODUCT=" "$iface/device/uevent" 2>/dev/null | cut -d= -f2 | cut -d/ -f1)
				product=$(grep "PRODUCT=" "$iface/device/uevent" 2>/dev/null | cut -d= -f2 | cut -d/ -f2)
				if [ -n "$vendor" ] && [ -n "$product" ]; then
					echo "| USB VID:PID | \`$vendor:$product\` |"
				fi
			fi

			# Module name (kernel driver)
			if [ -f "$iface/device/uevent" ]; then
				module=$(grep "DRIVER=" "$iface/device/uevent" 2>/dev/null | cut -d= -f2)
				if [ -n "$module" ]; then
					echo "| kernel module | \`$module\` |"
				fi
			fi

			# Device description from modalias
			if [ -f "$iface/device/modalias" ]; then
				modalias=$(cat "$iface/device/modalias" 2>/dev/null)
				echo "| modalias | \`$modalias\` |"
			fi

			# Check if interface is powered
			if [ -f "$iface/device/power/control" ]; then
				power_control=$(cat "$iface/device/power/control" 2>/dev/null)
				echo "| power control | \`$power_control\` |"
			fi

			# Wireless-specific info (only if tools responded to probe)
			if [ "$iw_works" = "1" ]; then
				log_h3 "$ifname Wireless Details"
				echo ""
				echo "| Property | Value |"
				echo "|----------|-------|"

				# PHY info
				phy=$(safe_iw dev "$ifname" info 2>/dev/null | grep wiphy | awk '{print $2}')
				if [ -n "$phy" ]; then
					echo "| PHY | phy$phy |"

					# Get phy info once and parse multiple values
					phy_info=$(safe_iw phy "phy$phy" info 2>/dev/null)
					if [ -n "$phy_info" ]; then
						channels=$(echo "$phy_info" | grep -c "MHz")
						[ "$channels" -gt 0 ] && echo "| Supported channels | $channels |"

						has_2ghz=$(echo "$phy_info" | grep -c "2... MHz")
						[ "$has_2ghz" -gt 0 ] && echo "| 2.4 GHz support | ✓ Yes ($has_2ghz channels) |"

						has_5ghz=$(echo "$phy_info" | grep -c "5... MHz")
						[ "$has_5ghz" -gt 0 ] && echo "| 5 GHz support | ✓ Yes ($has_5ghz channels) |"
					fi
				fi

				# Current connection status
				if [ -f "$iface/operstate" ] && [ "$(cat "$iface/operstate")" = "up" ]; then
					link_info=$(safe_iw dev "$ifname" link 2>/dev/null)
					if [ -n "$link_info" ]; then
						ssid=$(echo "$link_info" | grep SSID: | cut -d':' -f2- | sed -e 's/^[ \t]*//' -e 's/[ \t]*$//')
						if [ -n "$ssid" ] && [ "$ssid" != "Not connected." ]; then
							echo "| Connected SSID | \`$ssid\` |"

							freq=$(echo "$link_info" | grep freq: | awk '{print $2}')
							[ -n "$freq" ] && echo "| Frequency | ${freq} MHz |"

							signal=$(echo "$link_info" | grep signal: | awk '{print $2, $3}')
							[ -n "$signal" ] && echo "| Signal strength | $signal |"

							tx_bitrate=$(echo "$link_info" | grep "tx bitrate:" | sed 's/.*tx bitrate: \(.*\)/\1/')
							[ -n "$tx_bitrate" ] && echo "| TX bitrate | $tx_bitrate |"

							rx_bitrate=$(echo "$link_info" | grep "rx bitrate:" | sed 's/.*rx bitrate: \(.*\)/\1/')
							[ -n "$rx_bitrate" ] && echo "| RX bitrate | $rx_bitrate |"
						fi
					fi
				fi
			elif [ "$iwconfig_works" = "1" ]; then
				# Fallback: use iwconfig for basic wireless info
				log_h3 "$ifname Wireless Details (iwconfig)"
				echo ""
				echo "| Property | Value |"
				echo "|----------|-------|"

				iwcfg=$(safe_iwconfig "$ifname" 2>/dev/null)
				if [ -n "$iwcfg" ]; then
					# Extract what we can from iwconfig output
					essid=$(echo "$iwcfg" | grep -o 'ESSID:"[^"]*"' | cut -d'"' -f2)
					[ -n "$essid" ] && echo "| ESSID | \`$essid\` |"

					mode=$(echo "$iwcfg" | grep -o 'Mode:[^ ]*' | cut -d: -f2)
					[ -n "$mode" ] && echo "| Mode | $mode |"

					freq=$(echo "$iwcfg" | grep -o 'Frequency:[^ ]*' | cut -d: -f2)
					[ -n "$freq" ] && echo "| Frequency | $freq |"

					ap=$(echo "$iwcfg" | grep -o 'Access Point: [^ ]*' | cut -d' ' -f3)
					[ -n "$ap" ] && [ "$ap" != "Not-Associated" ] && echo "| Access Point | \`$ap\` |"

					bitrate=$(echo "$iwcfg" | grep -o 'Bit Rate[=:][^ ]*' | cut -d'=' -f2 | cut -d':' -f2)
					[ -n "$bitrate" ] && echo "| Bit Rate | $bitrate |"

					txpower=$(echo "$iwcfg" | grep -o 'Tx-Power[=:][^ ]*' | cut -d'=' -f2 | cut -d':' -f2)
					[ -n "$txpower" ] && echo "| TX Power | $txpower |"

					quality=$(echo "$iwcfg" | grep -o 'Link Quality[=:][^ ]*' | cut -d'=' -f2 | cut -d':' -f2)
					[ -n "$quality" ] && echo "| Link Quality | $quality |"

					signal=$(echo "$iwcfg" | grep -o 'Signal level[=:][^ ]*' | cut -d'=' -f2 | cut -d':' -f2)
					[ -n "$signal" ] && echo "| Signal Level | $signal |"
				fi
			fi

			# Check for wpa_supplicant status (only if probe succeeded)
			if [ "$wpa_works" = "1" ]; then
				wpa_status=$(safe_wpa_cli -i "$ifname" status 2>/dev/null)
				wpa_state=$(echo "$wpa_status" | grep "wpa_state=" | cut -d= -f2)
				if [ -n "$wpa_state" ]; then
					echo "| wpa_supplicant state | $wpa_state |"

					if [ "$wpa_state" = "COMPLETED" ]; then
						wpa_ssid=$(echo "$wpa_status" | grep "^ssid=" | cut -d= -f2)
						wpa_ip=$(echo "$wpa_status" | grep "ip_address=" | cut -d= -f2)
						[ -n "$wpa_ssid" ] && echo "| wpa SSID | \`$wpa_ssid\` |"
						[ -n "$wpa_ip" ] && echo "| wpa IP | \`$wpa_ip\` |"
					fi
				fi
			fi
		fi
	done 2>/dev/null

	if [ "$found_wifi" = "0" ]; then
		log_info "No WiFi interfaces found"
	fi

	# WiFi configuration files and kernel modules
	log_h2 "WiFi Configuration & Kernel Modules"

	echo ""
	echo "| File/Module | Status | Notes |"
	echo "|-------------|--------|-------|"

	# Check for common wpa_supplicant config locations
	for conf in /etc/wifi/wpa_supplicant.conf /appconfigs/wpa_supplicant.conf /config/wpa_supplicant.conf \
		/userdata/cfg/wpa_supplicant.conf /etc/wpa_supplicant/wpa_supplicant.conf; do
		if [ -f "$conf" ]; then
			networks=$(grep -c "^network=" "$conf" 2>/dev/null || echo "0")
			echo "| \`$conf\` | ✓ Exists | $networks network(s) configured |"
		fi
	done

	# Check for netplan (rg35xxplus)
	if [ -f /etc/netplan/01-netcfg.yaml ]; then
		echo "| \`/etc/netplan/01-netcfg.yaml\` | ✓ Exists | netplan config |"
	fi

	# Check for loaded WiFi kernel modules
	log_h3 "Loaded WiFi Kernel Modules"
	code_start
	lsmod 2>/dev/null | grep -E "8188fu|8821cs|rtl|brcm|ath|iwl|mt76" || echo "No common WiFi modules detected"
	code_end

	# Check for available WiFi kernel modules
	if [ -d /lib/modules/"$(uname -r)" ]; then
		log_h3 "Available WiFi Kernel Modules"
		code_start
		find /lib/modules/"$(uname -r)" -name "*wifi*" -o -name "*80211*" -o -name "*wlan*" 2>/dev/null | head -20 || echo "No WiFi modules found"
		code_end
	fi

	# Check for WiFi firmware
	log_h3 "WiFi Firmware"
	echo ""
	echo "| Path | Status |"
	echo "|------|--------|"
	for fw_dir in /lib/firmware /vendor/firmware /system/vendor/firmware; do
		if [ -d "$fw_dir" ]; then
			fw_count=$(find "$fw_dir" -name "*wifi*" -o -name "*wlan*" -o -name "*.bin" 2>/dev/null | wc -l | tr -d ' ')
			if [ "$fw_count" -gt 0 ]; then
				echo "| \`$fw_dir\` | $fw_count firmware file(s) |"
			fi
		fi
	done

	# Check for running WiFi processes
	log_h3 "WiFi Processes"
	code_start
	ps aux 2>/dev/null | grep -E "wpa_supplicant|hostapd|iw|dhcp" | grep -v grep || echo "No WiFi processes running"
	code_end

	log_h2 "Bluetooth Status"

	# Probe Bluetooth tools once to avoid repeated timeouts
	hciconfig_works=0
	bluetoothctl_works=0
	if command -v hciconfig >/dev/null 2>&1; then
		if safe_hciconfig 2>/dev/null | grep -q .; then
			hciconfig_works=1
		else
			log_warn "hciconfig timed out or failed - skipping detailed controller info"
		fi
	fi
	if command -v bluetoothctl >/dev/null 2>&1; then
		if printf '%s\n' "show" "quit" | safe_bluetoothctl 2>/dev/null | grep -q .; then
			bluetoothctl_works=1
		else
			log_warn "bluetoothctl timed out or failed - skipping runtime status"
		fi
	fi

	# Check for Bluetooth interfaces
	found_bt=0
	for hci in /sys/class/bluetooth/hci*; do
		if [ -d "$hci" ]; then
			found_bt=1
			hciname=$(basename "$hci")

			log_h3 "$hciname Hardware Info"
			echo "| Property | Value |"
			echo "|----------|-------|"

			# Basic info from sysfs (always safe)
			if [ -f "$hci/address" ]; then
				echo "| MAC address | \`$(cat "$hci/address" 2>/dev/null || echo 'N/A')\` |"
			fi
			if [ -f "$hci/name" ]; then
				echo "| name | \`$(cat "$hci/name" 2>/dev/null || echo 'N/A')\` |"
			fi

			# Chipset detection via driver
			if [ -L "$hci/device/driver" ]; then
				driver=$(basename "$(readlink "$hci/device/driver" 2>/dev/null)" || echo "")
				if [ -n "$driver" ]; then
					echo "| driver | \`$driver\` |"
				fi
			fi

			# USB chipset detection
			if [ -f "$hci/device/uevent" ]; then
				vendor=$(grep "PRODUCT=" "$hci/device/uevent" 2>/dev/null | cut -d= -f2 | cut -d/ -f1)
				product=$(grep "PRODUCT=" "$hci/device/uevent" 2>/dev/null | cut -d= -f2 | cut -d/ -f2)
				if [ -n "$vendor" ] && [ -n "$product" ]; then
					echo "| USB VID:PID | \`$vendor:$product\` |"
				fi
			fi

			# Modalias
			if [ -f "$hci/device/modalias" ]; then
				modalias=$(cat "$hci/device/modalias" 2>/dev/null)
				echo "| modalias | \`$modalias\` |"
			fi

			# Power state
			if [ -f "$hci/device/power/control" ]; then
				power_control=$(cat "$hci/device/power/control" 2>/dev/null)
				echo "| power control | \`$power_control\` |"
			fi

			# Controller details (only if hciconfig probe passed)
			if [ "$hciconfig_works" = "1" ]; then
				log_h3 "$hciname Controller Details"
				echo ""
				echo "| Property | Value |"
				echo "|----------|-------|"

				# Get hciconfig output once and parse
				hci_info=$(safe_hciconfig "$hciname" 2>/dev/null)
				if [ -n "$hci_info" ]; then
					hci_type=$(echo "$hci_info" | grep "Type:" | cut -d: -f2- | xargs)
					[ -n "$hci_type" ] && echo "| Type | $hci_type |"

					hci_bus=$(echo "$hci_info" | grep "Bus:" | cut -d: -f2- | xargs)
					[ -n "$hci_bus" ] && echo "| Bus | $hci_bus |"

					bd_addr=$(echo "$hci_info" | grep "BD Address:" | cut -d: -f2- | awk '{print $1}')
					[ -n "$bd_addr" ] && echo "| BD Address | \`$bd_addr\` |"

					acl_mtu=$(echo "$hci_info" | grep "ACL MTU:" | cut -d: -f2- | xargs)
					[ -n "$acl_mtu" ] && echo "| ACL MTU | $acl_mtu |"

					if echo "$hci_info" | grep -q "UP RUNNING"; then
						echo "| Controller state | ✓ UP and RUNNING |"
					elif echo "$hci_info" | grep -q "DOWN"; then
						echo "| Controller state | DOWN (disabled) |"
					fi
				fi
			fi

			# Runtime status (only if bluetoothctl probe passed)
			if [ "$bluetoothctl_works" = "1" ]; then
				log_h3 "$hciname Runtime Status"
				echo ""
				echo "| Property | Value |"
				echo "|----------|-------|"

				# Get bluetoothctl show output once and parse
				bt_show=$(printf '%s\n' "show" "quit" | safe_bluetoothctl 2>/dev/null)
				if [ -n "$bt_show" ]; then
					bt_powered=$(echo "$bt_show" | grep "Powered:" | awk '{print $2}')
					[ -n "$bt_powered" ] && echo "| Powered | $bt_powered |"

					bt_discoverable=$(echo "$bt_show" | grep "Discoverable:" | awk '{print $2}')
					[ -n "$bt_discoverable" ] && echo "| Discoverable | $bt_discoverable |"

					bt_pairable=$(echo "$bt_show" | grep "Pairable:" | awk '{print $2}')
					[ -n "$bt_pairable" ] && echo "| Pairable | $bt_pairable |"

					bt_discovering=$(echo "$bt_show" | grep "Discovering:" | awk '{print $2}')
					[ -n "$bt_discovering" ] && echo "| Discovering | $bt_discovering |"
				fi

				# Paired devices
				log_h3 "$hciname Paired Devices"
				paired_output=$(printf '%s\n' "paired-devices" "quit" | safe_bluetoothctl 2>/dev/null)
				paired_count=$(echo "$paired_output" | grep -c "Device" || echo "0")
				echo ""
				echo "- **$paired_count device(s) paired**"

				if [ "$paired_count" -gt 0 ]; then
					echo ""
					code_start
					echo "$paired_output" | grep "Device" || true
					code_end
				fi

				# Connected devices
				log_h3 "$hciname Connected Devices"
				connected_devices=$(printf '%s\n' "devices" "quit" | safe_bluetoothctl 2>/dev/null | grep "Device")
				if [ -n "$connected_devices" ]; then
					echo ""
					code_start
					echo "$connected_devices"
					code_end
				else
					log_info "No devices currently connected"
				fi
			fi
		fi
	done 2>/dev/null

	# Check rfkill status (critical for Bluetooth enable/disable)
	log_h2 "RF Kill Status"
	if command -v rfkill >/dev/null 2>&1; then
		code_start
		rfkill list all 2>/dev/null || echo "rfkill failed"
		code_end

		# Parse rfkill for Bluetooth specifically
		log_h3 "Bluetooth RF Kill State"
		echo ""
		echo "| Device | Type | Soft Blocked | Hard Blocked |"
		echo "|--------|------|--------------|--------------|"

		rfkill_output=$(rfkill list bluetooth 2>/dev/null)
		if [ -n "$rfkill_output" ]; then
			echo "$rfkill_output" | while read -r line; do
				if echo "$line" | grep -q "^[0-9]"; then
					device=$(echo "$line" | cut -d: -f2- | xargs)
					echo "| $device | bluetooth | ... | ... |"
				elif echo "$line" | grep -q "Soft blocked:"; then
					soft=$(echo "$line" | awk '{print $3}')
					echo "soft=$soft"
				elif echo "$line" | grep -q "Hard blocked:"; then
					hard=$(echo "$line" | awk '{print $3}')
					echo "hard=$hard"
				fi
			done | awk '
				/^soft=/ { soft=$0; sub(/soft=/, "", soft) }
				/^hard=/ { hard=$0; sub(/hard=/, "", hard) }
				/^\|/ && soft && hard {
					sub(/\.\.\.$/, soft, $0);
					sub(/\.\.\.$/, hard, $0);
					print;
					soft=""; hard=""
				}
				/^\|/ && !soft { print }
			'
		else
			log_info "No Bluetooth devices in rfkill"
		fi
	else
		log_info "rfkill not available - cannot check RF kill status"
	fi

	# Bluetooth configuration and tools
	log_h2 "Bluetooth Configuration & Tools"

	echo ""
	echo "| Tool/File | Status | Notes |"
	echo "|-----------|--------|-------|"

	# Check for bluetoothd daemon
	if ps aux 2>/dev/null | grep -q "[b]luetooth"; then
		echo "| bluetoothd daemon | ✓ Running | Main Bluetooth service |"
	else
		echo "| bluetoothd daemon | ✗ Not running | Bluetooth functionality unavailable |"
	fi

	# Check for bluetooth tools
	if command -v hciconfig >/dev/null 2>&1; then
		echo "| hciconfig | ✓ Available | Legacy HCI configuration tool |"
	else
		echo "| hciconfig | ✗ Not found | May use bluetoothctl instead |"
	fi

	if command -v bluetoothctl >/dev/null 2>&1; then
		echo "| bluetoothctl | ✓ Available | Modern BlueZ control tool |"
	else
		echo "| bluetoothctl | ✗ Not found | Cannot manage Bluetooth |"
	fi

	if command -v hcitool >/dev/null 2>&1; then
		echo "| hcitool | ✓ Available | Device scanning and info |"
	else
		echo "| hcitool | ✗ Not found | Limited scan capability |"
	fi

	# Check for Bluetooth config files
	for conf in /etc/bluetooth/main.conf /var/lib/bluetooth /etc/systemd/system/bluetooth.service; do
		if [ -e "$conf" ]; then
			if [ -d "$conf" ]; then
				count=$(find "$conf" -type f 2>/dev/null | wc -l | tr -d ' ')
				echo "| \`$conf\` | ✓ Exists (dir) | $count file(s) |"
			else
				echo "| \`$conf\` | ✓ Exists | Config file |"
			fi
		fi
	done

	# Check for Bluetooth kernel modules
	log_h3 "Bluetooth Kernel Modules"
	code_start
	lsmod 2>/dev/null | grep -E "bluetooth|btusb|btrtl|btbcm|hci" || echo "No Bluetooth modules detected"
	code_end

	# Check for available Bluetooth modules
	if [ -d /lib/modules/"$(uname -r)" ]; then
		log_h3 "Available Bluetooth Kernel Modules"
		code_start
		find /lib/modules/"$(uname -r)" -name "*bluetooth*" -o -name "*bt*" -o -name "*hci*" 2>/dev/null | grep -E "bluetooth|btusb|btrtl|btbcm|hci_" | head -20 || echo "No Bluetooth modules found"
		code_end
	fi

	# Check for Bluetooth firmware
	log_h3 "Bluetooth Firmware"
	echo ""
	echo "| Path | Status |"
	echo "|------|--------|"
	for fw_dir in /lib/firmware /vendor/firmware /system/vendor/firmware; do
		if [ -d "$fw_dir" ]; then
			bt_fw_count=$(find "$fw_dir" -name "*bt*" -o -name "*bluetooth*" -o -name "BCM*.hcd" -o -name "rtl_bt*" 2>/dev/null | wc -l | tr -d ' ')
			if [ "$bt_fw_count" -gt 0 ]; then
				echo "| \`$fw_dir\` | $bt_fw_count firmware file(s) |"
			fi
		fi
	done

	if [ "$found_bt" = "0" ]; then
		log_info "No Bluetooth interfaces found"
	fi
}

###############################################################################
# Main
###############################################################################

main() {
	log_h1 "SYSTEM REPORT"
	log_info "Generated: $(date '+%Y-%m-%d %H:%M:%S')"
	log_info "Platform: ${PLATFORM:-unknown}"

	# Core hardware detection (most important for platform bring-up)
	progress 5 "Device tree detection"
	fn_device_tree

	progress 10 "CPU frequency scaling"
	fn_cpu_scaling

	progress 15 "CPU benchmark"
	fn_cpu_benchmark

	progress 50 "GPU detection"
	fn_gpu

	progress 55 "Display info"
	fn_display

	progress 58 "Audio subsystem"
	fn_audio

	# Architecture and binary compatibility
	progress 62 "Architecture detection"
	fn_arch_test

	progress 65 "SDL libraries"
	fn_sdl_libraries

	# System state
	progress 68 "System information"
	fn_system

	progress 72 "Kernel modules"
	fn_modules

	# Hardware interfaces
	progress 75 "Hardware paths"
	fn_hardware

	progress 78 "PWM detection"
	fn_pwm

	progress 80 "Bus enumeration"
	fn_buses

	progress 83 "Special hardware"
	fn_special_hardware

	progress 86 "Power management"
	fn_power_management

	# Environment and config
	progress 90 "Environment variables"
	fn_environment

	progress 93 "Network interfaces"
	fn_network

	# Debug info (at end since it's verbose)
	progress 97 "Kernel messages"
	fn_dmesg

	progress 100 "Complete!"
	log_h1 "END OF REPORT"
}

main "$@"
