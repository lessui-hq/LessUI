#!/bin/sh
# Enable WiFi service

BIN_DIR="$(dirname "$0")"
PAK_DIR="$(dirname "$BIN_DIR")"

# shellcheck source=wifi-lib.sh
. "$BIN_DIR/wifi-lib.sh"
setup_wifi_paths "$PAK_DIR"

main() {
	normalize_platform

	echo "Preparing to enable wifi..."

	# Update system.json for platforms that use it
	SYSTEM_JSON_PATH="$(get_system_json_path)"
	if [ -n "$SYSTEM_JSON_PATH" ]; then
		set_system_wifi "$SYSTEM_JSON_PATH" 1
	fi

	# Unblock wireless if rfkill is available
	if command -v rfkill >/dev/null 2>&1; then
		echo "Unblocking wireless..."
		rfkill unblock wifi 2>/dev/null || true
	fi

	echo "Starting wpa_supplicant..."

	case "$PLATFORM" in
		miyoomini)
			killall wpa_supplicant 2>/dev/null || true
			killall udhcpc 2>/dev/null || true

			# Load WiFi kernel module if needed
			if ! grep -q 8188fu /proc/modules 2>/dev/null; then
				insmod "$PAK_DIR/res/miyoomini/8188fu.ko"
			fi

			/customer/app/wpa_cli -i wlan0 disconnect 2>/dev/null || true
			/customer/app/wpa_cli -i wlan0 terminate 2>/dev/null || true
			/customer/app/wpa_cli -i wlan0 reconfigure 2>/dev/null || true

			ifconfig lo up
			/customer/app/axp_test wifion
			sleep 2
			ifconfig wlan0 up
			/customer/app/wpa_supplicant -B -D nl80211 -iwlan0 -c /appconfigs/wpa_supplicant.conf

			if ! wait_for_process wpa_supplicant 30; then
				echo "Failed to start wpa_supplicant"
				return 1
			fi

			ln -sf /dev/null /tmp/udhcpc.log
			udhcpc -i wlan0 -s /etc/init.d/udhcpc.script &

			/customer/app/wpa_cli -i wlan0 reconnect
			iw dev wlan0 set power_save off
			;;

		tg5040)
			killall -15 wpa_supplicant 2>/dev/null || true
			killall -15 udhcpc 2>/dev/null || true
			ifconfig wlan0 up 2>/dev/null || true

			wpa_supplicant -B -D nl80211 -iwlan0 -c /etc/wifi/wpa_supplicant.conf -O /etc/wifi/sockets >/tmp/wpa_supplicant.log 2>&1

			# Handle stale socket file
			if grep -q "Delete '/etc/wifi/sockets/wlan0' manually" /tmp/wpa_supplicant.log 2>/dev/null; then
				killall -15 wpa_supplicant 2>/dev/null || true
				rm -f /etc/wifi/sockets/wlan0
				wpa_supplicant -B -D nl80211 -iwlan0 -c /etc/wifi/wpa_supplicant.conf -O /etc/wifi/sockets
			fi
			rm -f /tmp/wpa_supplicant.log

			if ! wait_for_process wpa_supplicant 30; then
				echo "Failed to start wpa_supplicant"
				return 1
			fi
			udhcpc -i wlan0 -n &
			;;

		my282)
			killall -9 wpa_supplicant 2>/dev/null || true
			killall -9 udhcpc 2>/dev/null || true
			ifconfig wlan0 up 2>/dev/null || true

			if ! /etc/init.d/wpa_supplicant start; then
				echo "Failed to start wpa_supplicant via init.d"
			fi

			if ! wait_for_process wpa_supplicant 30; then
				echo "Failed to start wpa_supplicant"
				return 1
			fi
			( (udhcpc -i wlan0 -q &) &)
			;;

		my355)
			killall -9 wpa_supplicant 2>/dev/null || true
			killall -9 udhcpc 2>/dev/null || true
			ifconfig wlan0 up 2>/dev/null || true

			wpa_supplicant -B -D nl80211 -iwlan0 -c /userdata/cfg/wpa_supplicant.conf

			if ! wait_for_process wpa_supplicant 30; then
				echo "Failed to start wpa_supplicant"
				return 1
			fi
			( (udhcpc -i wlan0 -q &) &)
			;;

		rg35xxplus)
			ip link set wlan0 up

			# Disable power save if iw is available
			if command -v iw >/dev/null 2>&1; then
				iw dev wlan0 set power_save off 2>/dev/null || true
			fi

			# Stop services for clean state
			systemctl stop systemd-networkd 2>/dev/null || true
			systemctl stop wpa_supplicant 2>/dev/null || true
			sleep 1

			# Start wpa_supplicant and wait for it to be active
			systemctl start wpa_supplicant

			# Wait for wpa_supplicant (longer timeout for systemd overhead)
			if ! wait_for_service wpa_supplicant 50; then
				echo "Failed to start wpa_supplicant"
				systemctl status wpa_supplicant --no-pager 2>&1 || true
				return 1
			fi

			# Only start systemd-networkd after wpa_supplicant is ready
			systemctl start systemd-networkd

			# Apply netplan with timeout to avoid hanging on slow/unavailable networks
			if ! timeout 15 netplan apply 2>/dev/null; then
				echo "Warning: netplan apply timed out or failed (continuing anyway)"
				# Don't return 1 - WiFi might still work, just slower to connect
			fi
			;;

		rgb30 | retroid)
			# IWD-based platforms (LessOS)
			echo "Starting IWD WiFi..."

			WIFI_DEV="$(get_wifi_interface)"

			# Try wifictl first (LessOS native tool)
			if command -v wifictl >/dev/null 2>&1; then
				echo "Using wifictl..."
				wifictl enable 2>/dev/null || true
				sleep 1
				wifictl connect 2>/dev/null || true
			else
				# Fall back to manual IWD control
				echo "Using iwctl..."

				# Bring up the interface
				ip link set "$WIFI_DEV" up 2>/dev/null || true

				# Unblock WiFi via rfkill if available
				if command -v rfkill >/dev/null 2>&1; then
					rfkill unblock wifi 2>/dev/null || true
				fi

				# Disable power save if iw is available
				if command -v iw >/dev/null 2>&1; then
					iw dev "$WIFI_DEV" set power_save off 2>/dev/null || true
				fi

				# Ensure IWD is running (should already be started by system)
				if ! pgrep -x iwd >/dev/null 2>&1; then
					echo "Starting IWD daemon..."
					if ! systemctl start iwd 2>/dev/null; then
						/usr/lib/iwd &
						sleep 1  # Allow daemon to initialize after background start
					fi
				fi

				# Wait for IWD to be ready
				if ! wait_for_process iwd 50; then
					echo "Failed to start IWD"
					return 1
				fi

				# Power on the WiFi adapter via iwctl
				iwctl device "$WIFI_DEV" set-property Powered on 2>/dev/null || true

				# Trigger a scan to find networks
				iwctl station "$WIFI_DEV" scan 2>/dev/null || true
			fi

			# IWD handles DHCP internally via EnableNetworkConfiguration=true
			# No need to start systemd-networkd or external DHCP client
			;;

		*)
			echo "$PLATFORM is not a supported platform for WiFi.pak"
			return 1
			;;
	esac
}

main "$@"
