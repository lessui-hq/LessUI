#!/bin/sh
# Enable WiFi service

BIN_DIR="$(dirname "$0")"
PAK_DIR="$(dirname "$BIN_DIR")"

# shellcheck source=wifi-lib.sh
. "$BIN_DIR/wifi-lib.sh"
setup_wifi_paths "$PAK_DIR"

main() {
	echo "Preparing to enable wifi..."

	# Update system.json for platforms that use it
	SYSTEM_JSON_PATH="$(get_system_json_path)"
	if [ -n "$SYSTEM_JSON_PATH" ]; then
		set_system_wifi "$SYSTEM_JSON_PATH" 1
	fi

	# Unblock wireless if rfkill is available
	if command -v rfkill >/dev/null 2>&1; then
		echo "Unblocking wireless..."
		rfkill unblock wifi 2>/dev/null || true
	fi

	echo "Starting wpa_supplicant..."

	case "$PLATFORM" in
		miyoomini)
			killall wpa_supplicant 2>/dev/null || true
			killall udhcpc 2>/dev/null || true

			# Load WiFi kernel module if needed
			if ! grep -q 8188fu /proc/modules 2>/dev/null; then
				insmod "$PAK_DIR/res/miyoomini/8188fu.ko"
			fi

			/customer/app/wpa_cli -i wlan0 disconnect 2>/dev/null || true
			/customer/app/wpa_cli -i wlan0 terminate 2>/dev/null || true
			/customer/app/wpa_cli -i wlan0 reconfigure 2>/dev/null || true

			ifconfig lo up
			/customer/app/axp_test wifion
			sleep 2
			ifconfig wlan0 up
			/customer/app/wpa_supplicant -B -D nl80211 -iwlan0 -c /appconfigs/wpa_supplicant.conf

			if ! wait_for_process wpa_supplicant 30; then
				echo "Failed to start wpa_supplicant"
				return 1
			fi

			ln -sf /dev/null /tmp/udhcpc.log
			udhcpc -i wlan0 -s /etc/init.d/udhcpc.script &

			/customer/app/wpa_cli -i wlan0 reconnect
			iw dev wlan0 set power_save off
			;;

		tg5040)
			killall -15 wpa_supplicant 2>/dev/null || true
			killall -15 udhcpc 2>/dev/null || true
			ifconfig wlan0 up 2>/dev/null || true

			wpa_supplicant -B -D nl80211 -iwlan0 -c /etc/wifi/wpa_supplicant.conf -O /etc/wifi/sockets >/tmp/wpa_supplicant.log 2>&1

			# Handle stale socket file
			if grep -q "Delete '/etc/wifi/sockets/wlan0' manually" /tmp/wpa_supplicant.log 2>/dev/null; then
				killall -15 wpa_supplicant 2>/dev/null || true
				rm -f /etc/wifi/sockets/wlan0
				wpa_supplicant -B -D nl80211 -iwlan0 -c /etc/wifi/wpa_supplicant.conf -O /etc/wifi/sockets
			fi
			rm -f /tmp/wpa_supplicant.log

			if ! wait_for_process wpa_supplicant 30; then
				echo "Failed to start wpa_supplicant"
				return 1
			fi
			udhcpc -i wlan0 -n &
			;;

		my282)
			killall -9 wpa_supplicant 2>/dev/null || true
			killall -9 udhcpc 2>/dev/null || true
			ifconfig wlan0 up 2>/dev/null || true

			if ! /etc/init.d/wpa_supplicant start; then
				echo "Failed to start wpa_supplicant via init.d"
			fi

			if ! wait_for_process wpa_supplicant 30; then
				echo "Failed to start wpa_supplicant"
				return 1
			fi
			( (udhcpc -i wlan0 -q &) &)
			;;

		my355)
			killall -9 wpa_supplicant 2>/dev/null || true
			killall -9 udhcpc 2>/dev/null || true
			ifconfig wlan0 up 2>/dev/null || true

			wpa_supplicant -B -D nl80211 -iwlan0 -c /userdata/cfg/wpa_supplicant.conf

			if ! wait_for_process wpa_supplicant 30; then
				echo "Failed to start wpa_supplicant"
				return 1
			fi
			( (udhcpc -i wlan0 -q &) &)
			;;

		rg35xxplus)
			ip link set wlan0 up

			# Disable power save if iw is available
			if command -v iw >/dev/null 2>&1; then
				iw dev wlan0 set power_save off 2>/dev/null || true
			fi

			# Stop services for clean state
			systemctl stop systemd-networkd 2>/dev/null || true
			systemctl stop wpa_supplicant 2>/dev/null || true
			sleep 1

			# Start wpa_supplicant and wait for it to be active
			systemctl start wpa_supplicant

			# Wait for wpa_supplicant (longer timeout for systemd overhead)
			if ! wait_for_service wpa_supplicant 50; then
				echo "Failed to start wpa_supplicant"
				systemctl status wpa_supplicant --no-pager 2>&1 || true
				return 1
			fi

			# Only start systemd-networkd after wpa_supplicant is ready
			systemctl start systemd-networkd

			# Apply netplan with timeout to avoid hanging on slow/unavailable networks
			if ! timeout 15 netplan apply 2>/dev/null; then
				echo "Warning: netplan apply timed out or failed (continuing anyway)"
				# Don't return 1 - WiFi might still work, just slower to connect
			fi
			;;

		rgb30 | retroid)
			# IWD-based platforms (LessOS)
			# IWD is a D-Bus service that auto-activates when iwctl is used
			echo "Starting IWD WiFi..."

			WIFI_DEV="$(get_wifi_interface)"

			# Unblock WiFi via rfkill first (this is what wifictl enable does)
			if command -v rfkill >/dev/null 2>&1; then
				echo "Unblocking rfkill..."
				rfkill unblock wifi 2>/dev/null || true
			fi

			# Use iwctl to interact with IWD (this auto-activates IWD via D-Bus)
			echo "Checking IWD device list..."
			iwctl device list 2>&1 || true

			# Wait for device to appear
			echo "Waiting for WiFi device $WIFI_DEV..."
			for _ in $(seq 1 10); do
				if iwctl device list 2>/dev/null | grep -q "$WIFI_DEV"; then
					echo "Device $WIFI_DEV found in IWD"
					break
				fi
				sleep 0.5
			done

			# Power on the device
			echo "Powering on WiFi device..."
			iwctl device "$WIFI_DEV" set-property Powered on 2>&1 || true

			# Check device status
			echo "Device status:"
			iwctl device "$WIFI_DEV" show 2>&1 || true

			# Wait for device to be powered on
			if ! wait_for_iwd_powered "$WIFI_DEV" 50; then
				echo "Failed to power on WiFi device"
				echo "Checking if IWD process exists:"
				pgrep -a iwd 2>&1 || echo "No IWD process found"
				ps aux | grep -i iwd 2>&1 || true
				return 1
			fi
			echo "WiFi device powered on successfully"

			# Set station mode
			iwctl device "$WIFI_DEV" set-property Mode station 2>/dev/null || true

			# Disable power save if iw is available
			if command -v iw >/dev/null 2>&1; then
				iw dev "$WIFI_DEV" set power_save off 2>/dev/null || true
			fi

			# Give device a moment to fully initialize before first scan
			echo "Waiting for device to be ready for scanning..."
			sleep 2

			# Trigger initial scan so networks are available faster
			echo "Triggering network scan..."
			iwctl station "$WIFI_DEV" scan 2>/dev/null || true

			# IWD handles DHCP internally via EnableNetworkConfiguration=true
			;;

		*)
			echo "$PLATFORM is not a supported platform for WiFi.pak"
			return 1
			;;
	esac
}

main "$@"
