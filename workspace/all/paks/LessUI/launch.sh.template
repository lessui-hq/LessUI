#!/bin/sh
# LessUI.pak - Generated launch script
# DO NOT EDIT - regenerate with: make -C workspace/all/paks/LessUI setup

{{HOOK:pre-init}}
#######################################
# Environment setup

export PLATFORM="{{PLATFORM}}"
export PLATFORM_ARCH="{{PLATFORM_ARCH}}"
# Use LESSOS_STORAGE if set (LessOS), otherwise use build-time default
export SDCARD_PATH="${LESSOS_STORAGE:-{{SDCARD_PATH}}}"
export BIOS_PATH="$SDCARD_PATH/Bios"
export SAVES_PATH="$SDCARD_PATH/Saves"
export SYSTEM_PATH="$SDCARD_PATH/.system/$PLATFORM"
export CORES_PATH="$SDCARD_PATH/{{CORES_SUBPATH}}"
export USERDATA_PATH="$SDCARD_PATH/.userdata/$PLATFORM"
export SHARED_USERDATA_PATH="$SDCARD_PATH/.userdata/shared"
export LOGS_PATH="$USERDATA_PATH/logs"
export DATETIME_PATH="$SHARED_USERDATA_PATH/datetime.txt"

#######################################
# Create directories

mkdir -p "$USERDATA_PATH"
mkdir -p "$LOGS_PATH"
mkdir -p "$SHARED_USERDATA_PATH/.launcher"

#######################################
# PATH setup

export PATH="$SYSTEM_PATH/bin:$SDCARD_PATH/.system/common/bin/$PLATFORM_ARCH:$PATH"
export LD_LIBRARY_PATH="$SYSTEM_PATH/lib:$LD_LIBRARY_PATH"

#######################################
# Logging
#
# Native C binaries use LOG_FILE environment variable for file logging.
# Each binary launch sets LOG_FILE inline for clarity and consistency.
# Shell scripts use log.sh library for their own logging.
# LOG_SYNC=1 enables crash-safe mode (fsync after each log write).
# Slower but ensures logs survive crashes - uncomment for debugging.
# export LOG_SYNC=1

if [ -f "$SDCARD_PATH/.system/common/log.sh" ]; then
	. "$SDCARD_PATH/.system/common/log.sh"
	log_init "$LOGS_PATH/shell.log"
	log_info "LessUI starting for $PLATFORM"
fi

{{HOOK:init}}
type log_info >/dev/null 2>&1 && log_info "Platform init complete"
#######################################
# User auto.sh

if [ -f "$USERDATA_PATH/auto.sh" ]; then
	"$USERDATA_PATH/auto.sh"
fi

cd "$(dirname "$0")"

{{HOOK:late-init}}
#######################################
# Main loop

EXEC_PATH="/tmp/launcher_exec"
NEXT_PATH="/tmp/next"
touch "$EXEC_PATH" && sync

type log_info >/dev/null 2>&1 && log_info "Entering main loop"

while [ -f "$EXEC_PATH" ]; do
	cpu_restore 2>/dev/null || true
	type pre_launcher_hook >/dev/null 2>&1 && pre_launcher_hook

	type log_info >/dev/null 2>&1 && log_info "Starting launcher.elf"
	LOG_FILE="$LOGS_PATH/launcher.log" launcher.elf
	LAUNCHER_EXIT=$?
	type log_info >/dev/null 2>&1 && log_info "launcher.elf exited with code: $LAUNCHER_EXIT"

	echo "$(date +'%F %T')" > "$DATETIME_PATH"
	sync

	if [ -f "$NEXT_PATH" ]; then
		type pre_pak_hook >/dev/null 2>&1 && pre_pak_hook
		CMD=$(cat "$NEXT_PATH")
		PAK_NAME=$(echo "$CMD" | sed -n 's|.*/\([^/]*\)\.pak/.*|\1|p')
		[ -z "$PAK_NAME" ] && PAK_NAME="pak"

		# Dual logging strategy:
		# - LOG_FILE env var: Used by native C binaries via log_open()
		# - Stdout/stderr redirect: Captures output from shell-only paks
		# Well-behaved C binaries use LOG_* macros exclusively, so redirect is harmless
		LOG_FILE="$LOGS_PATH/${PAK_NAME}.log" eval "$CMD" > "$LOGS_PATH/${PAK_NAME}.log" 2>&1

		shui stop 2>/dev/null
		rm -f "$NEXT_PATH"

		if [ -f "/tmp/using-swap" ]; then
			swapoff "$USERDATA_PATH/swapfile"
			rm -f "/tmp/using-swap"
		fi

		cpu_restore 2>/dev/null || true
		echo "$(date +'%F %T')" > "$DATETIME_PATH"
		sync
	fi

	type loop_tail_hook >/dev/null 2>&1 && loop_tail_hook
done

{{SHUTDOWN_CMD}}
